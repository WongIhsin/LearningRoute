# 编译原理Compilers Principles, Techniques, and Tools

------

# —————2019/7/17—————

# 第四章：语法分析

## 4.1 语法分析器的作用

语法分析器接收词法分析器提供的记号串，检查它们是否能由源程序语言的文法产生。能用易于理解的方式提示语法错误信息，并能从常见的错误中恢复过来，以便后面的输入能继续处理下去

典型的文法的语法分析器有三类。一类是通用的语法分析方法：能分析任何文法，然而这些方法在生成编译器时效率太低。编译器常用的是自顶向下和自底向上的方法

不论哪一种方法，语法分析器都是自左向右地扫描输入字符串，每次读一个符号

最有效的自顶向下和自底向上分析方法只能处理文法的一些子类。然而。这些子类中的某些文法，如LL文法和LR文法，足以描述程序设计语言的大部分语法结构

LL文法的语法分析器常由手工实现，大多数LR文法的语法分析器则常利用自动生成工具来构造

### 4.1.1 语法错误的处理

如果编译器只处理正确程序，它的设计和实现就可以大大简化。但是程序设计人员经常会编写出错误的程序，因此好的编译器应该能帮助程序员识别和定位错误。虽然错误经常发生，但是绝大多数语言在设计时都没有考虑到出错处理

大多数程序设计语言的说明都没有描述编译器应该怎样响应语法错误，而是把它留给了编译器的设计者来处理

因此，在设计编译器的开始阶段我们就应该规划出错处理策略，这样既可以简化编译器的结构也能改进它对错误的响应能力

程序错误的实例：词法错误、语法错误、语义错误、逻辑错误

#### ==源程序的多数错误诊断和恢复都集中在语法分析阶段==

原因之一是多数错误都是语法错误，或者当来自词法分析器的记号流违背定义程序设计语言的文法规则时才暴露出来。另一个原因是现代语法分析方法的准确性使得他们能非常有效地检查出程序中的语法错误

#### ==语法分析器中出错处理程序的基本目标是==

+ 清楚而准确地报告错误的出现
+ 迅速地从每个错误中恢复过来，以遍能继续检查后面的错误
+ 不能过分降低正确程序的处理速度

幸好，常见的错误都是简单错误，用相对简单的错误处理机制就足以处理这些错误

有些情况下，错误的发生远远先于发现它的位置，而且很难诊断出这种错误的准确性质。更困难的是，出错处理程序可能需要猜测程序员编程时的意图

有些分析方法，如LL方法和LR方法，可以尽快地检查出语法错误。更准确地说，它们具有==萌发前缀性viable-prefix property==，即当它们一旦发现一个输入字符串的前缀不是该语言任何字符串的前缀时就能检查出错误

#### ==出错处理程序应该怎么报告错误呢==

至少，它们应该报告源程序的错误被检测到的位置。很多编译器普遍采用的方法是：显示出错的程序行，用指针指出检测到的错误的位置。如果能够知道实际错误可能是什么，编译器还会显示附带的诊断信息，如“此处遗漏了分号”等

#### ==语法分析器如何恢复错误==

有很多一般性的策略，但没有哪种策略占绝对优势。多数情况下，语法分析器在检测到一个错误后就放弃继续分析的做法是不妥的，因为继续处理输入字符串可发现更多的错误。通常一些语法分析器试图将自己恢复到某一状态，以便能够继续分析输入字符串或正确地处理出现的错误

#### 不充分地恢复程序可能会引起大量“伪”错误的出现，是由于错误恢复时改变了语法分析器的状态而引起的，也可能引起语义伪错误

编译器的一个保守的策略是：如果在输入流中查到某个错误，并且它离前一个错误非常近，则抑制这个错误信息的出现，即在发现一个语法错误后，编译器应该在成功地分析几个记号之后才报告下一个错误信息。某些情况下，可能有太多的错误，以至于编译器无法继续进行合理的处理。错误处理的策略是一个需要认真考虑的折中。

#### 事实上，随着交互式计算以及良好程序设计环境日趋重要，错误恢复机制将趋于简单化

### 4.1.2 错误恢复策略

几种策略已经得到广泛应用

+ 紧急方式恢复策略
  ==最容易实现的方法，适用于多数语法分析方法==。当发现错误时，语法分析器开始抛弃输入记号，每次抛弃一个记号，直到发现某个指定的同步记号为止。同步记号通常是定界符，如分号或end。常常跳过大量的输入记号，而不检查其中是否有其他错误。所以，==当一个语句中出现的错误数较少时，这种方法比较合适==
+ 短语级恢复策略
  发现错误时，语法分析器对剩余的输入字符串做局部纠正，即用一个能使语法分析器继续工作的字符串来代替剩余输入的前缀。典型的局部纠正包括用分号代替逗号、删除多余的分号或插入遗漏的分号。必须小心，以免引起死循环。这种类型的替换可以纠正任何输入字符串，已经被用在多个错误修复编译器中，该方法首先被用于自顶向下的语法分析中。它的==主要缺点是难以应付实际错误出现在诊断点之前的情况==
+ 出错产生式策略
  如果对经常遇到的错误有很清楚的了解，可以扩充语言的文法，增加产生错误结构的产生式，然后用由错误产生式扩充的文法构造语法分析器。如果语法分析器使用了出错产生式，就可以产生适当的错误诊断信息，指出我们在输入字符串中识别出的错误结构
+ 全局纠正策略
  总是希望在处理不正确的输入字符串时做尽可能少的改动，选择最小的修改序列，以获得全局代价最小的错误纠正。不幸的是，==实现这些算法的时间和空间开销太大，目前人们只是进行了一些理论上的探讨==

#### 必须指出，最近似正确的纠错程序并不一定是程序员所关心的，然而，==“最小代价纠正”==的概念已经成为评价错误恢复技术的一种标准，并且已经被用于短语级恢复方法中最优替换字符串的选择

## 4.2 上下文无法文法

上下文无关文法由**终结符**、**非终结符**、**开始符号**和**产生式**组成

1. 终结符是组成字符串的基本符号，在讨论程序设计语言的文法时，记号和终结符是同义词
2. 非终结符是表示字符串集合的语法变量。非终结符所定义的字符串集合有助于定义该文法所产生的语言，非终结符强加给语言一种层次结构，这种层次结构对语法分析和翻译都非常有用
3. 在文法中，有一个非终结符被指定为开始符号，开始符号表示的字符串集合就是文法所定义的语言
4. 文法的产生式说明了终结符和非终结符组合成串的方式

### 4.2.1 符号的使用约定

本书中终结符包括：字母表中比较靠前的小写字母，如a、b、c等；操作符+-等；标点符号；数字；黑体串

本书中非终结符包括：字母表中比较靠前的大写字母，如A、B、C等；字母S，它常常代表开始符号；小写斜体名字，如expr、stmt等

### 4.2.2 推导

推导是描述文法定义语言过程的有用方法，其==核心思想是把产生式看成重写规则，即用产生式右部的串来代替左部的非终结符。事实上，推导给出了自顶向下构造分析树过程的精确描述==

对于开始符号为S的文法G，L(G)中的字符串只包含G的终结符。当且仅当S可以一步或多步推导出w时，我们说终结符串w在L(G)中，终结符串w称为G的**句子**。由上下文无关文法产生的语言称为**上下文无关语言**。如果两个文法产生同样的语言，则称这两个文法**等价**。

对于开始符号为S的文法G，如果S可以零步或多步推导出α，则称α为G的**句型**，其中α可能含有非终结符。句子是不含非终结符的句型

考虑每一步都替代最左非终结符的推导。这样的推导叫做最左推导

如果S可以零步或多步最左推导出α，则称α是该文法的**左句型**

类似可以定义**最右推导**，即每步推导都替代最右非终结符的推导，最右推导有时也称为**规范推导**

### 4.2.3 分析树和推导

分析树可以看成是推导的图形表示，但它不能显示出替代顺序的选择。分析树的每个内节点都标以某个非终结符A。A的子节点从左到右分别被用来替换A所使用的产生式右部的各符号标记，分析树的叶节点用非终结符或终结符来标记，它们从左到右构成一个句型，称为树的边界或果实

如果只考虑最左推导（或最右推导），则可以消除推导过程中产生式应用顺序的不一致，不能看出

#### 每棵分析树都有一个与之对应的唯一的最左推导和唯一的最右推导

#### 然后，每一个句子不一定只有一个分析树，或者说不一定只有一个最左推导或最右推导分析树

### 4.2.4 二义性

给定一个文法G，如果L(G)中存在一个具有两棵或两棵以上分析树的句子，则称G是二义性的；也可以如下定义二义性文法：如果L(G)中存在一个具有两个或两个以上最左(或最右)推导的句子，则G是二义性文法

很多语法分析器要求所处理的文法是无二义的，否则对具有二义性的句子无法确定应该选择哪颗分析树。某些应用可能要求我们可以构造适应于二义性文法的语法分析器，不过，这种文法要求具有消除二义性的规则，以便语法分析器能够“抛弃”不需要的分析树而为每个句子保留唯一一棵分析树

## 4.3 文法的编写

文法能描述程序设计语言的大部分语法成分，但不能描述程序设计语言的全部语法成分

对输入字符串的某些限制，如标识符的声明必须先于它们的使用，不能用上下文无关文法来描述。因此，语法分析器接受的记号序列形成了程序设计语言的超集。语法分析以后的各编译阶段必须分析语法分析器的输出，以保证输入字符串符合语法分析器无法检查的那些规则

==每种语法分析方法只能处理一种形式的文法。为了适应所选择的分析方法，常常不得不改写初始文法==

### 4.3.1 正规表达式和上下文无关文法的比较

正规表达式所描述的每一种结构都可以用上下文无关文法来描述

可以机械地把一个不确定的有穷自动机NFA转换成一个等价的上下文无关文法

1. 对NFA的每个状态i，创建一个非终结符Ai
2. 如果状态i遇见输入符号a转换到状态j，则引入产生式Ai→aAj
3. 如果状态i遇见输入符号ε转换到状态j，则引入产生式Ai→Aj
4. 如果状态i是接受状态，则引入产生式Ai→ε
5. 如果状态i是开始状态，则Ai是文法的开始符号

#### 为什么要使用正规表达式而不用上下文无关文法来定义语言的词法

1. 语言的词法规则通常非常简单，不必动用强大的文法来描述
2. 对于记号，正规表达式比上下文无关文法提供了更简洁且易于理解的定义
3. 从正规表达式可以自动地构造出有效的词法分析器，从任何文法都很难构造词法分析器
4. 把语言的语法结构分成词法和非词法两部分为编辑器前端的模块划分提供了方便的途径

对于任何一种语言来说，哪些结构应作为词法规则，哪些结构应作为语法规则，并没有严格的界限。正规表达式对描述标识符、常数和关键字等词法结构最有用。另一方面，文法在描述括号配对、begin-end配对、if-then-else对应等嵌套结构时最有用。正规表达式不能描述这些嵌套结构

### 4.3.2 验证文法所产生的语言

对文法G产生语言L的证明包括两部分：必须证明由G产生的每个字符串都在L中；反之，L中的每个字符串都能由G产生

### 4.3.3 消除二义性

例如stmt → **if** expr **then** stmt
                 |  **if** expr **then** stmt **else** stmt
                 |  **other**

有两棵分析树。所有包含这种条件语句的程序设计语言都使用第一种分析树，即一般规则是，每个**else**和前面最近的没有配对的**then**配对。这条避免二义性的规则可以直接并入文法中

修改后，基本思想是：出现在**then**和**else**之间的语句必须是配对的，即它不能以一个未配对的**then**后面跟随任意的非**else**语句结束，于是**else**会被迫与这个未配对的**then**匹配。配对的语句是一个不包含不配对语句的**if-then-else**语句或者任何非条件语句

stmt → matched_stmt
          |  unmatched_stmt
matched_stmt → **if** expr **then** matched_stmt **else** matched_stmt
                            | **other**
unmatched_stmt → **if** expr **then** stmt
                                 | **if** expr **then** matched_stmt **else** unmatched_stmt

### 4.3.4 消除左递归

如果文法G具有一个非终结符A使得对某个字符串α存在推导A通过一步或多步推导成Aα，则称G是**左递归**的。自顶向下语法分析不能处理左递归文法，因此需要一种消除左递归的变换

A → Aα|β可以由下面的非左递归产生式来代替：
A → βA‘
A’ → αA‘|ε

这种变换没有改变从A推导出的字符串集合，这条规则适用于很多文法

无论有多少A产生式，都可以用下面的技术来消除直接左递归。首先，把A产生式放在一起：A → Aα1|Aα2|...|Aαm|β1|β2|...|βn

其中，每个βi都不以A开头。然后用下面的产生式代替A产生式

A → β1A’|β2A’|...|βnA’
A‘ → α1A’|α2A’|...|αmA’|ε

变换后的非终结符A与变换前的非终结符A产生同样的字符串集合，但已经没有左递归了，这种方法可以从A产生式和A‘产生式（假定αi都不等于ε）消除直接左递归，==但不能消除包括两步或多步推导的左递归==

#### 算法4.1 消除左递归

输入：无循环推导和ε产生式的文法G

输出：与G等价的无左递归文法

方法：对文法G应用下面算法，注意，得到的非左递归文法可能含有ε产生式

```c
1.以某种顺序排列非终结符A1，A2，...，An；
2.for i := 1 to n do begin
      for j:=1 to i-1 do begin
          用产生式Aj → β1γ|β2γ|...|βkγ代替每个形如Ai → Ajγ的产生式
          其中，Aj → β1|β2|...|βk是所有的当前Aj产生式
      end
      消除Ai产生式中的直接左递归
  end
# 不太确定，书上看不清
```

### 4.3.5 提取左因子

提取左因子是一种对产生适合预测分析的文法非常有用的文法变换。提取左因子的基本思想是：当不清楚应该用两个选择中的哪一个来替换非终结符A时，可改写A产生式来推迟这种决定，直到看见足够多的输入能做出正确选择为止

一般地，如果A → αβ1|αβ2是A的两个产生式，输入字符串由从α导出的非空串开始，我们不知道是用αβ1来扩展A还是用αβ2。然而，可以通过先将A扩展到αA’来推迟这个决定，然后，扫描完由α导出的输入字符串后，再把A‘扩展成β1或β2，亦即**提取左因子**

#### 算法4.2 提取左因子

输入：文法G

输出：一个等价的提取了左因子的文法

方法：对每个非终结符A，找出他的两个或更多侯选式的最长公共前缀α，如果α不等于ε，即有一个非平凡的公共前缀，则用下面的产生式代替所有A产生式A → αβ1|αβ2|...|αβn|γ，其中γ表示所有不以α开头的侯选式
A → αA’|γ
A' → β1|β2|...|βn

反复应用这种变换，直到任一非终结符都没有两个侯选式具有公共前缀为止

### 4.3.6 非上下文无关语言的结构==（没有懂为什么）==

有些语言不能用任何文法产生。事实上，在很多程序设计语言中，仅用文法难以完成某些语法结构的说明

例如：L1 = {wcw|w属于(a|b)*}。L1是所有由c隔开的两个相同a、b串组成的字母串集合，例如abbcabb。这个语言是检查程序中标识符的声明应先于其引用的抽象，即wcw中的第一个w表示标识符w的声明，第二个w表示它的引用。可以证明该语言不是上下文无关语言

L2 = {anbmcndm|n>=1且m>=1}不是上下文无关语言

由于上述原因，一些程序设计语言并不定义标识符中的字符，而只是用文法中id这样的记号代表所有的标识符，在这类语言的编译器中，语义分析阶段检查标识符的声明是否先于引用

类似的还有在语义分析阶段检查call中的实参个数是否正确

S → aSb|ab是不能用正规表达式表示的典型例子。L3'

通俗地讲，我们说“有穷自动机不能计数”是指有穷自动机不能接受像L3'这样的语言（它要求在看到b之前记住a的个数）。类似地，我们说上下文无关文法能计2项的数，但不能计3项的数

## 4.4 自顶向下语法分析

自顶向下语法分析的基本概念以及构造无回溯自顶向下语法分析器的方法。无回溯自顶向下语法分析器也称为预测语法分析器

### 4.4.1 递归下降语法分析器

自顶向下语法分析的目的是为输入字符串寻找最左推导，或者说，从根节点（文法开始符号）开始，自上而下、从左到右地为输入字符串建立一棵分析树，并以预先确定的顺序创建分析树的节点

自顶向下分析的一般形式，称为==递归下降分析法==。他可能需要回溯，即需要重复地扫描输入。然而，需要回溯的语法分析器是不常见的，其原因是在分析程序设计语言的结构时很少需要回溯

当需要回溯时，建议使用一种记录输入轨迹的方法

考虑下述文法和输入字符串w=cad

S → cAd
A → ab|a

首先建立只具有标记为S的单个节点的树，输入指针指向w的第一个符号c，然后，我们用S的第一个产生式来扩展该树，最左边的叶子标记为c，匹配w的第一个符号，输入指针移到w的第二个符号a，考虑下一个标记为A的叶子，用A的第一个侯选式扩展A，匹配了第二个输入符号a，再将输入指针移到第三个输入符号d，把它和下一个标记为b的叶节点进行比较，因为b和d不匹配，报告失败，回到A，看是否有其他侯选式可试。尝试A的第二种侯选式，叶子a匹配w的第二个符号，叶子d匹配w的第三个符号，因为已经产生了w的分析树，停止分析并宣告分析成功

虽然递归下降语法分析器带有回溯能力，左递归文法也会使其进入无限循环，也就说，在试图扩展某个非终结符时，输入指针并没有前移

### 4.4.2 预测语法分析器

在许多情况下，通过仔细地编写文法，消除左递归，提取左因子，我们可以获得一个有效的文法，这个文法可以用不带回溯的递归下降语法分析器来分析

对给定的当前输入符号a和将要扩展的非终结符A，在A的所有可选产生式A → α1|α2|...|αn中，哪个侯选式是唯一能推导出以a开头的串。预测语法分析器能够通过观察侯选式所推导出的第一个符号，确定正确的候选式。这种方法可以检测出多数程序设计语言中具有不同关键字的控制流结构

### 4.4.3 预测语法分析器的状态转换图

对于预测语法分析器，每个非终结符都对应一个状态转换图，边上的标记是记号和非终结符，记号（终结符）上的转换意味着如果该记号是下一个输入符号，就应进行该转换。非终结符A上的转换是对与A对应的过程的调用

为了由文法构造预测语法分析器的状态转换图，首先需要消除文法中的左递归，然后提取左因子，并对每个非终结符A执行如下操作：

1. 创建一个开始状态和一个终态（返回状态）
2. 对每个产生式A → X1X2...Xn，创建一条从开始状态到终止状态的路径，边上的标记分别为X1，X2，...，Xn

工作方式如下：开始，语法分析器进入状态图的开始状态，输入指针指向输入符号串的第一个符号。如果经过一些动作后，语法分析器进入状态s，且在状态图上从状态s到状态t的边上标记终结符a，而下一个输入符又正好是a，则语法分析器将输入指针向右移动一位指向下一个符号，语法分析器进入状态t。另一方面，如果边上标记的是非终结符A，则语法分析器进入A的初始状态，但不移动输入指针。一旦语法分析器到达A的终止状态，则立刻进入状态t，事实上，语法分析器从状态s转移到状态t时，它已经从输入符号串“读”了A。最后，如果从s到t有一条标记为ε的边，那么语法分析器从状态s直接进入状态t而不移动输入指针

如果给定的状态转换图是确定的，即一个状态对于一个输入仅有一个转换，则上述方法是有效的。如果出现二义性使用如下方法。如果不能消除不确定性，就不能构造预测语法分析器，这时可以构造递归下降语法分析器，用回溯的方法尝试所有可能的情况

例如唯一的二义性在于确定是否经过ε边，如果把出边解释为：如果下一个输入是+，则选择+上的转换，否则选择ε上的转换，以此来消除二义性

### 4.4.4 非递归的预测分析

通过显式地维护一个状态栈，而不是通过隐式的递归调用，我们可以构造非递归的预测语法分析器

预测分析的关键问题就是确定用于扩展非终结符的产生式

如何从文法直接构造分析表

表驱动的预测语法分析器由一个输入缓冲区、一个栈、一张分析表和一个输入流。输入缓冲区包含要分析的串、后面跟一个符号$是输入串的结束标记，栈用来存放文法符号序列。栈底符号是$。初始时，栈中含有文法的开始符号及其下边的$，分析表是一个二维数组M[A,a]，A是非终结符，a是终结符或$

程序根据栈顶当前的符号X和当前输入符号a决定语法分析器的动作：

1. 如果X=a=$，则语法分析器宣告分析成功并停止
2. 如果X=a!=$，则语法分析器弹出栈顶符号X，并将输入指针移到下一个输入符号上
3. 如果X是非终结符，则程序访问分析表M的M[X,a]项，M[X,a]项是文法的一个X产生式或者是出错信息。如果M[X,a] = {X → UVW}，则语法分析器用WVU（U在栈顶）代替栈顶符号X。如果M[X,a] = error，则语法分析器调用错误恢复程序

#### 算法4.3 非递归的预测分析

输入：串w和文法G的分析表M

输出：如果w属于L(G)，则输出w的最左推导，否则报告错误

方法：开始时，语法分析器的格局是$S在栈里（其中S是G的开始符号且在栈顶），w$在输入缓冲区

```c
令ip指向w$的第一个符号;
repeat
    令X是栈顶符号，a是ip指向的符号;
    if X是终结符或者是$ then
        If X=a then
            从栈中弹出X，ip指向下一个符号
        else error()
    else    /* X是非终结符 */
        if M[X,a] = X→Y1Y2...Yk then begin
            从栈中弹出X;
            将Yk,Yk-1,...,Y1压入栈，Y1在栈顶;
            输出产生式X→Y1Y2...Yk
        end
        else error()
 until X=$    /* 栈空 */
```

### 4.4.5 FIRST和FOLLOW

构造文法G的分析表需要两个与G有关的函数FIRST和FOLLOW，由FOLLOW函数产生的记号集合还可用做紧急方式错误恢复期间的同步记号

定义FIRST(α)是从α推导出的串的开始符号的终结符集合，定义FOLLOW(A)是包含所有在句型中紧跟在A后面的终结符的集合

如下计算任何串X1X2...Xn的开始符号集合FIRST(X1X2...Xn)，将FIRST(X1)中的所有非ε符号加到FIRST(X1X2...Xn)中，如果ε属于FIRST(X1)，还要加入FIRST(X2)中所有非ε符号，以此类推，如果ε属于所有的FIRST(Xi)，则把ε加入FIRST(X1X2...Xn)中

计算FOLLOW(A)，我们可以应用如下规则，直到每个FOLLOW集合都不能再加入任何符号或$为止：

1. 将$放入FOLLOW(S)中，其中S是开始符号，$是输入串的结束符
2. 如果存在产生式A → αBβ，则将FIRST(β)中除ε之外的符号都放入FOLLOW(B)中
3. 如果存在产生式A → αB，或者A → αBβ，其中FIRST(β)中包含ε，则将FOLLOW(A)中的所有符号都放入FOLLOW(B)中

### 4.4.6 预测分析表的构造

基本思想是：如果A → α是产生式且a在FIRST(α)中，那么当前输入符号为a时，语法分析器将用α展开A。唯一的复杂情况发生在α=ε或者α通过零步或多步推导可以推导出ε时，在这种情况下，如果当前输入符号属于FOLLOW(A)，或者如果输入已经到达$而$在FOLLOW(A)中，语法分析器仍将用α展开A

#### 算法4.4 构造预测分析表

输入：文法G

输出：分析表M

方法：1.对于文法中的每个产生式A → α，执行第2步和第3步
2.对FIRST(α)中的每个终结符a，将A → α加入到M[A, a]中
3.若ε在FIRST(α)中，则对FOLLOW(A)的每个终结符b，将A → α加入到M[A, b]中；若ε在FIRST(α)中，且$在FOLLOW(A)中，则将A → α加入到M[A, $]中
4.将M中每个没定义的表项均置为error

### 4.4.7 LL(1)文法

若文法G是左递归或者是二义性的，则产生的分析表M至少包含一个多重定义的表项

分析表中没有多重定义表项的文法叫做**LL(1)**文法。LL(1)中的第一个L代表从左向右扫描输入，第二个L代表产生最左推导，1代表在决定语法分析器的每步动作时向前扫描一个输入符

#### 可以证明，算法4.4可以为任何LL(1)文法G产生分析表

这个分析表能分析G的所有句子，而且只能分析G的句子

当分析表中含有多重定义的表项时，一种办法是进行文法变换，消除左递归和提取所有可能的左因子，以期产生的新文法的分析表中没有多重定义的表项。不幸的是一写文法无论如何也不能产生LL(1)文法。==一般来说，没有一个普遍适用的规则可以用来删除多重定义的表项，使其成为单值而不影响语法分析器所识别的语言==

使用预测分析的==主要困难在于为源语言编写一个能构造出预测语法分析器的文法==，虽然消除左递归和提取左因子都非常简单，但它们使得结果文法很难阅读而且不易于翻译。为降低上述难度

#### 编译器中语法分析器常常同时使用两种方法，即使用==预测分析方法分析控制结构==，使用==算符优先分析方法分析表达式==

如果LR语法分析器的生成器可用，则可以自动获得预测分析和算符优先分析的一切优点

### 4.4.8 预测分析的错误恢复

非递归预测语法分析器的栈使得语法分析器希望同剩余输入串进行匹配的终结符和非终结符变得十分清楚。因此，在下面的讨论中，将引用栈中符号

紧急方式错误恢复策略主要基于以下思想：跳过一些输入符号，直到期望的同步记号中的一种出现为止。它的效果依赖于同步记号集合的选择。这些集合的选择应该使得语法分析器能迅速地从实际可能发生的错误中恢复过来

1. 开始，把FOLLOW(A)中的所有符号放入非终结符A的同步记号集合中。如果出现错误时的栈顶元素是A，可以跳过一些记号，直接看见FOLLOW(A)中的元素，再把A弹出栈。这样就可以继续进行语法分析
2. 例如，分号用于表示语句结束时，赋值语句分号的遗漏会导致下一语句的开始关键字被跳过。可以把高层结构的开始符号加到低层结构的同步集合中。例如，可以把表示语句开始的关键字加入产生表达式的非终结符的同步集合中
3. 如果把FIRST(A)的符号加入非终结符A的同步集合，那么可以恢复关于A的分析，只要FIRST(A)的符号出现在输入中
4. 如果非终结符能产生空串，则可以将产生空串的产生式作为默认选择，==这样做会延迟某些错误的发现，但不会漏掉，而且这种方法可以减少错误恢复时要考虑的非终结符数==
5. 如果栈顶的终结符不能被匹配，那么简单的办法就是弹出该终结符，并给出提示信息，说明输入中插入了该符号，然后继续进行分析。实际上，这种方式等于把其他的记号作为该记号的同步集合

通过在预测分析表的空白表项填上出错处理程序指针即可实现**短语级恢复**。这些程序可以修改、插入或删除输入符号并给出适当的出错信息。它们也可能弹出栈中的符号。如果允许替换栈顶符号或者将新的符号压入栈定可能会出问题，因为这样会使得语法分析器执行的步骤跟语言中任何词的推导都不对应

不管怎样，必须确保不会产生无限循环。有一种很好的方法可以防止这种循环，即==确认所有的恢复动作最终都将会使剩余输入串缩短（或者，如果到了输入的末端，使栈缩短）==

## 4.5 自底向上语法分析

一种比较常见的自底向上分析法，称为==移动归约分析法==，一种最易于实现的移动归约分析法，称为==算符优先分析法==，更一般的移动归约分析方法叫做==LR分析法==。LR分析法可用于许多自动的语法分析器的生成器

移动归约分析法为输入串构造分析树时从叶节点（底端）开始，向根节点（顶端）前进。可以把该过程看成是把输入串w“归约”成文法开始符号的过程。在每一步**归约reduction**中，如果一个子串和某个产生式的右部匹配，则用该产生式的左部符号代替该子串。==如果每一步都能恰当地选择子串，就可以得到最右推导的逆过程==

### 4.5.1 句柄

非形式地，一个符号串的“句柄”是和一个产生式右部匹配的子串，而且把它归约到该产生式左部的非终结符代表了最右推导逆过程的一步。在很多情况下，匹配某个产生式A → β右部的最左输入子串β不是句柄，因为用这个产生式归约产生的串不能归约成开始符号

形式地说，右句型（最右推导可得到的句型）γ的句柄是一个产生式A → β以及γ的一个位置，在该位置可以找到串β，而且用A代替β可以得到γ的最右推导的前一个右句型，即如果S零步或多步右推导出αAw，右推导出αβw，紧跟在α后面的A → β是αβw的句柄。句柄右侧的串w只包含终结符

### 4.5.2 句柄裁剪

通过“裁剪句柄”可以得到最右推导的逆过程，我们从被分析的终结符串w开始，如果w是文法的一个句子，那么w=γn，在γn中找到句柄βn，并用产生式An → βn的左部代替βn，得到第n-1步的右句型γn-1。重复此过程，即在γn-1中找到句柄βn-1，并对该句柄进行归纳得到右句型γn-2，继续此过程，将得到只包含开始符号S的右句型，那么就宣告分析成功并停止，在归约过程中所用产生式序列的逆序就是输入串的最右推导

### 4.5.3 用栈实现移动归约分析

两个问题，一是定位右句型中将要归约的子串；二是这个子串是多个产生式的右部，如何确定选择哪一个产生式

使用栈来保存文法符号，用输入缓冲区来保存要分析的串w，用$来标记栈底，也用它来标记输入串的右端

语法分析器将零个或多个输入符号压入栈，直到句柄β在栈顶出现为止，语法分析器再把β归约成某个恰当的产生式的左部。重复此过程，直到它发现错误或者栈中只含有开始符号并且输入串为空。此时语法分析器停止并宣告分析成功

移动归约语法分析器的基本动作是移动和归约，实际上有四种可能的动作

1. 移动：把下一个输入符号移动到栈顶
2. 归约：语法分析器知道句柄的右端已在栈顶。它必须在栈中确定句柄的左端，并选择正确的非终结符替代句柄
3. 接受：语法分析器宣告分析成功
4. 出错：语法分析器发现了一个语法错误，并调用错误恢复程序进行错误处理

#### 句柄最终总会出现在栈顶，而不是在栈的里面

在执行了一步归约之后，语法分析器都必须移动零个或多个符号以便使下一个句柄进栈。语法分析器不需要深入到栈中去寻找句柄

### 4.5.4 活前缀

出现在移动归约语法分析器栈中的右句型的前缀集合成为活前缀

### 4.5.5 移动归约分析过程中的冲突

有些上下文无关文法不能使用移动归约分析方法进行分析：根据栈中的内容和下一个输入符号不能决定是移动还是归约（移动——归约冲突），或不能决定按哪一个产生式进行归约（归约——归约冲突）称之为非LR文法。LR(k)中的k代表超前搜索k个输入符号，编译中使用的文法通常都属于LR(1)类，即超前搜索一个输入符号

一般地说，任何二义性文法都不是LR(k)文法（对任何k）。必须指出，对移动归约分析方法进行简单的改造即可分析某些二义性文法。如果通过优先使用移动来解决这个冲突，语法分析器就能正常工作了

## 4.6 算符优先分析法

LR文法是一大类适合移动归约语法分析器的文法

对于一小部分非常重要的文法，可以很容易地手工构造有效的移动归约语法分析器。这些文法具有下面的性质：所有产生式的右部都不是ε或两个相邻的非终结符。具有第二个性质的文法称为**算符文法**

一种易于实现的语法分析技术，即**算符优先分析**

有很多缺点，减号既是一元操作符又是二元操作符，很难处理。同时不能肯定语法分析器接受的就是所期望的语言

#### 由于算符优先分析技术比较简单，很多编译器的语法分析器经常采用算符优先分析技术对表达式进行分析，对于语句和高级结构的分析则采用递归下降分析法。有些编译器的语法分析器甚至对整个语言都采用算符优先技术进行语法分析

### 4.6.1 使用算符优先关系

优先关系主要用于界定右句型的句柄。`<·`标记句柄的左端，`=`出现在句柄的内部，`·>`标记句柄的右端

#### 算法4.5 算符优先分析算法

输入：输入字符串w和优先关系表

输出：如果w是一个句子，则输出一个分析树架子，它的所有内节点均由占位非终结符E来标注；否则指出错误

方法：初始时，栈中放入$，输入缓冲区放入w$

```c
令ip指向w$的第一个符号;
repeat forever
    if $在栈顶而且ip指向$ then
        return
    else begin
        令a是栈中最上面的终结符，而b是ip所指向的符号;
        if a <· b 或 a = b then begin
            将b压入栈中;
            ip指向下一个输入符号;
        end;
        else if a ·> b then    /*归约*/
            repeat
                从栈中弹出符号
            until 栈顶终结符与最近弹出的终结符之间满足 <·
        else error()
    end
```

### 4.6.2 从结合律和优先级获得算符优先关系

1. 如果操作符θ1比θ2具有更高的优先级，则θ1·>θ2和θ2<·θ1都成立，这些关系可以确保形如E + E * E + E的表达式中，中间的E * E是先被归约的句柄
2. 如果θ1和θ2是同优先级的操作符（可以是同一个操作符），那么当它们满足左结合律时，θ1·>θ2和θ2·>θ1成立；右结合律时θ1<·θ2和θ2<·θ1成立，这些关系确保在E - E + E中，E - E会被选为句柄
3. 对于所有的操作符θ来说，θ<·id、id·>θ、θ<·(、（<·θ、)·>θ、θ·>)、θ·>$、$<·θ均成立，(=)、$<·(、$<·id、(<·(、id·>$、)·>$、(<·id、id·>)、)·>)也都成立。这些规则可以确保id和(E)都会被归约为E，而且只要$作为左右两端的标记，就可能会促使在$之间找到句柄

### 4.6.3 处理一元操作符

一元前缀操作符~，对于任何操作符θ，无论是一元还是二元的，均使θ<·~成立。如果~比θ的优先级高，则使用~·>θ成立，否则~<·θ成立

对于类似减号的既是一元前缀操作符又是二元中缀操作符，最好的办法是用词法分析器来区分一元和二元减号，当他看到一元的减号时返回不同的记号。遗憾的是，词法分析器不能通过超前扫描来区分这两者，它必须记住前一个记号（没懂）

### 4.6.4 优先函数

使用算符优先语法分析器的编译器不需要存储优先关系表。在大多数情况下，该表可以用两个**优先函数**f和g来表示，f和g把终结符映射为整数，对于符号a和b，f(a)>g(b)，如果a·>b

#### 算符4.6 优先函数的构造

输入：算符优先表

输出：表示输入矩阵的优先函数，或指出它不存在

方法：1.为每个终结符a或$创建符号fa和ga
2.把生成的符号按下面的方式分成尽可能多的组：如果a=b，则fa和gb在同一组
3.构造一个以2中的符号组为节点的有向图，对任意的a和b，如果a<·b，则从gb所在的组引出一条边指向fa所在的组。从fa到gb的边或路径意味着f(a)必超过g(b)
4.如果3中构造的图中有环路，则不存在优先函数，如果没有环路，则将f(a)设为从fa所在的组开始的最长路径的长度，g(a)设为从ga所在的组开始的最长路径的长度

### 4.6.5 算符优先分析中的错误恢复

能发现两种情况下的错误：

1. 如果栈顶的终结符和当前输入之间没有优先关系
2. 如果发现句柄，但句柄不是任何产生式的右部

#### 4.6.5.1 归约时的错误处理

处理情况2，因为没有用于归约的产生式，所以没有语义动作，而只是打印诊断信息

#### 4.6.5.2 处理移动归约错误

处理情况1，必须修改栈、输入或者两者都修改。小心不要进入死循环。一种不陷入死循环的方法：确保在恢复后能够把当前输入符号移动进栈

## 4.7 LR语法分析器

有效的自底向上语法分析技术，这种技术叫做LR(k)分析法，L指的是从左到右扫描输入字符串，R指的是构造最右推导的逆过程，k指的是在决定语法分析动作时需要向前看的符号个数

+ LR语法分析器能识别几乎所有能用上下文无关文法描述的程序设计语言的结构
+ LR分析法是已知的最一般的无回溯移动归约语法分析法，而且可以和其他移动归约分析法一样被有效地实现
+ LR分析法分析的文法类是预测分析法能分析的文法类的真超集
+ 在自左向右扫描输入符号串时，LR语法分析器能及时发现语法错误

主要缺点是，对典型的程序设计语言文法，手工构造LR语法分析器的工作量太大，因而需要专门的工具，即LR语法分析器的生成器

### 4.7.1 LR语法分析算法

输入、输出、栈、驱动程序以及包含动作action和转移goto两部分的语法分析表构成的。驱动程序对所有的LR语法分析器都是一样的，不同的语法分析器只是语法分析表有所不同

分析程序每次从输入缓冲区读入一个符号，并使用栈来存储形如s0X1s1X2s2...Xmsm的串，其中sm在栈顶，Xi是文法符号，si是称为**状态**的符号，每个状态符号概括了栈中位于它下面的信息。栈顶的状态符号和当前的输入符号用来检索语法分析表，以决定移动归约分析的动作。在实际实现中，文法符号不必出现在栈里

驱动LR语法分析器的程序工作如下：它根据栈顶状态sm和当前输入符号ai访问action[sm, ai]，即sm和ai所对应的语法分析表项的动作部分，可能的动作如下：移动状态s进栈、按文法产生式A → β归约、接受、出错

函数goto以状态和文法符号为参数，产生一个状态。用SLR、规范的LR或LALR方法从文法G构造的语法分析表的goto函数是识别G的活前缀的确定有穷自动机的转换函数

语法分析器的下一个动作是用当前输入符号ai和栈顶状态sm查询语法分析表的表项action[sm, ai]

所有的LR语法分析器都以这种方式工作，只是语法分析表的action和goto域的信息有所不同

#### 算法4.7 LR分析算法

输入：文法G的LR语法分析表和输入串w

输出：如果w属于L(G)，则输出w的自底向上分析，否则报错

方法：首先，把初始状态s0放在语法分析器栈顶，把w$放在输入缓冲区；然后，语法分析器执行如下，直到遇见接受或出错动作为止

```c
令ip指向w$的第一个符号;
repeat forever begin
    令s是栈顶的状态，a是ip所指向的符号;
    if action[s,a]="移动状态s'进栈" then begin
        把a和s'依次压入栈顶
        让ip指向下一个输入符号
    end
    else if action[s,a]="按文法产生式A→β归约" then begin
        从栈顶弹出2*|β|个符号;
        令s'是现在的栈顶状态;
        把A和goto[s',A]依次压入栈;
        输出产生式A→β
    end
    end if action[s,a]="接受" then
        return
    else error()
end
```

### 4.7.2 LR文法

如果能为文法G构造出LR语法分析表，则称G是LR文法。很多上下文无关文法不是LR文法。典型的程序设计语言的结构一般都可以避免非LR文法

LL文法和LR文法之间有明显的区别，对于LR(k)文法，我们必须通过向前看k个输入符号就能够知道一个产生式的右部所能推导出的所有字符串，进而识别出这个产生式右部的出现。这个要求远不如LL(k)那么严格，LL(k)文法要求只要看到了产生式右部推出的前k个符号后就能识别出用于归约的产生式。所以LR文法比LL文法描述的语言更多

### 4.7.3 构造SLR语法分析表

SLR功能最弱，最易实现

主要思想是首先从文法构造出识别活前缀的确定有穷自动机

#### 4.7.3.1 闭包运算closure

#### 4.7.3.2 goto函数

#### 4.7.3.3 项目集的构造

#### 4.7.3.4 SLR语法分析表

### 4.7.4 构造规范LR语法分析表

### 4.7.5 构造LALR语法分析表

### 4.7.6 LALR语法分析表的有效构造方法

# ==真的看不下去了==

### 4.7.7 LR语法分析表的压缩

## 4.8 二义文法的应用

任何二义文法都不是LR文法，但某些二义文法对语言的说明和实现非常有用。对于像表达式这样的语言结构，二义文法比任何等价的非二义文法提供的说明都要更短、更自然。另外，为了便于对一些特例语法结构进行优化，需要将他们从一般语法结构中分离出来，通过使用二义文法，往文法中增加新的产生式，我们就能标识这些特例结构，这是二义文法的另一种应用

#### 使用的文法是二义性的，但在所有情况下都说明了消除二义的规则，以保证对每个句子只有一棵分析树。这样，整个语言的说明仍然是无二义的

### 4.8.1 使用优先级和结合规则来解决分析动作的冲突

### 4.8.2 悬空else的二义性

### 4.8.3 特例产生式引起的二义性

### 4.8.4 LR语法分析中的错误恢复

## 4.9 语法分析器的生成器

### 4.9.1 语法分析器的生成器Yacc

### 4.9.2 用Yacc处理二义文法

### 4.9.3 用Lex建立Yacc的词法分析器

### 4.9.4 Yacc的错误恢复