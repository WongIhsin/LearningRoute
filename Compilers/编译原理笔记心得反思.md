阅读书籍为编译原理，该书也被称为龙书，是李建中教授翻译版

这本书的内容很多，基本没有废话，或许是我的知识范围不够，第一章简介部分就感觉晦涩难懂，以至于笔记基本把全章都抄下来了

（应该是这样的）本书的结构：第一章是简介，第二到第八章是一部分：词法分析、语法分析、中间代码生成，第九到第十章是一部分：代码生成和代码优化

# 编译原理Compilers Principles, Techniques, and Tools

首先是个人的几点理解，学习一项工具或一项技术，需要把握这项技术的整体脉络。对于编译器的历史需要有一定的了解

#### 1.早期编译器的编写，或者说第一个编译器是怎么来的

第一个编译器的出现时间很难说出准确的时间，而且早期的编译器的很多实验和实现是由不同的工作小组独立完成的。编译器大概出现在20世纪50年代，编译器的编写那时候一直被认为是一个极难的问题，Fortran的第一个编译器花了很多人大概三年时间才完成。

现在已经发展出很多技术、软件工具、环境，一个编译器的编写可以作为一个学生实习项目在一个学期内完成

#### 2.目前编译器的实现单纯靠手工是不可能实现的

已经发展出很多编译器的编译器的工具，使用了相当复杂的算法

#### 3.语法分析的魅力或许早已褪色，但编译技术一直是一个活跃的研究课题

#### 4. 编译器的结构大概是

源代码——中间代码——汇编代码

---







# —————2019/7/11—————















# 第一章：编译简介

---

#### 1.编译器的基本过程

词法分析——语法分析——语义分析——中间代码生成——代码优化——代码生成

每一步也都有——**符号表管理**——和——**错误处理**——的相关内容

#### 2.编译器的这些阶段并不需要在实际实现中明确分开，编译器的有些阶段可以合并到一起

#### 3.还有预处理、装配器和连接编辑器

这里涉及到一些汇编的知识。而且注意到整个流程中的**符号表**和汇编时候的**符号表**，虽然名字一样，但是却没有什么实质性的联系







---

# 第二章：简单的一遍编译器

---

#### 1. 上下文无关文法，贯穿本书始末

#### 2. 产生式production

#### 3. ==个人理解==：关于终结符和非终结符，龙书上提及了记号这个词，暂且先把记号认为是终结符吧，应该记号的范围比终结符的范围大

#### 4. 分析树

#### 5. 语法制导定义和翻译模式

后缀表示：(9-5)+2的后缀表示为95-2+，9-(5+2)的后缀表示为952+-

#### 6. 语法分析

编译器可能没有真正构造这样一棵分析树，但是，语法分析器应该具有构造分析树的能力，否则，不能保证翻译的正确性

使用软件工具直接从翻译模式生成翻译器是构造翻译器的理想方法

我们可以为任何文法构造语法分析器，对于任意上下文无关文法， 可以构造一个时间复杂性为O(n^3)的语法分析器

#### 7. 预测语法分析器不会有回溯问题

#### 8. 预测语法分析器不能处理左递归文法

#### 9. 词法分析

#### 10. 词法分析器和语法分析器形成==“生产者-消费者”==对

使词法分析器成为语法分析器调用并为语法分析器返回所需的记号的过程

#### 11. 符号表

#### 12. 抽象堆栈机

赋值语句可以形式化地表示如下：==stmt → id := expr { stmt.t := 'lvalue' || id.lexeme || expr.t || ':='}==

#### 13. 自己思考的两个问题

1.label冲突问题，具体实现

2.label定位问题，计算机基本要素里面说可以通过扫描两遍得到label具体地址，汇编层面。但现在是在中间代码层面来说的

#### 14. 技巧

表达式expr1 or expr2可以实现为：if expr1 then true else expr2

下面代码可以实现or操作：

expr1的代码
copy
gotrue out
pop
expr2的代码
label out

==gotrue和gofalse指令弹出栈顶数值来简化条件语句和while语句的代码生成。通过备份expr1的值，可以保证：如果gotrue指令产生转移，则栈顶值为真==









# —————2019/7/15—————

# 第三章：词法分析

#### 1. ==记号的返回通常是通过传递代表这个记号的整数来实现的==

#### 2. ==记号影响语法分析，而属性影响记号的翻译==

#### 3. 在实际实现时，记号通常只有一个属性，即指向符号表中一个表项的指针，与记号有关的信息保存在这个对应的表项中

#### 4. 因为词法分析器不能从全局的角度考察源程序，所以能在词法层发现的错误是有限的

#### 5. 有时会出现由于剩余输入的前缀不能和任何记号的模式匹配而使词法分析器无法处理的情况。

此时，最简单的错误恢复策略也许是”紧急方式“恢复，即反复删掉剩余输入最前面的字符，直到词法分析器能发现一个正确的记号为止。这种恢复技术可能会给语法分析带来一些麻烦，但在交互计算环境中是非常有效的

#### 6. 词法分析器是编译器中唯一的逐个字符读取源程序的阶段，所以他可能会耗费大量的时间，因此，在设计编译器时，词法分析器的速度是一个关键因素

#### 7. 双缓冲区和标志

标志就是在双缓冲区的两端缓冲区末尾加上eof标志

#### 8. 这里的正规表达式和正则表达式==不一样==？？（不是很确定）

正规表达式是和有限自动机相互转换，来判断是否和相应的输入输出对应

正则表达式是用于验证输入是否符号要求

#### 9. 重复符号串不能用正规表达式表示

集合（wcw|w是a和b组成的串）不能用正规表达式描述，也不能用上下文无关文法来说明

#### 10. 正规表达式只能表示固定次数的重复或给定结构的没有指定次数的重复。由于正规表达式不能比较任意两个数是否相等

这里说的固定次数应该是编写代码时候确定的次数，而不是运行时候来判断次数

#### 11. 一般来说，我们不为关键字单独构造状态转换图

#### 12. 把识别空白符的状态装换图放在较前面将有利于提高效率

#### 13. 当在某一个状态上既可以根据ε也可以根据一个实际的输入符号进行转换时，会引起歧义，==这种多值转换函数使我们很难用计算机程序模拟NFA==

#### 14. 从NFA变换到DFA的基本思想

是让DFA的每个状态对应NFA的一个状态集，这个DFA用它的状态去记住NFA在读输入符号后到达的所有状态。也就是说，在读了输入a1a2...an后，DFA到达一个代表NFA的状态子集T的状态，这个子集T是从NFA的开始状态沿着那些标有a1a2...an的路径能到达的所有状态的集合。DFA的状态数有可能是NFA状态数的指数，但实际上，这种最坏的情况很少发生

#### 15. NFA会关系到前n个状态吧，这样就感觉像是和时序有关的转换图了==（不懂）==

其实也不算，因为转换时候一些状态也只能从另一些状态转化而来

#### 16. 从NFA到DFA的变换，从正规表达式到NFA

N(r)的状态数最多是r中符号和运算符个数的两倍，因为构造的每步最多引入两个新状态，即起始状态和接受状态

---

#### 有穷自动机，不太理解，不太能和其他知识联系起来

---

























# 第四章：语法分析

