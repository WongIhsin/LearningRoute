# 编译原理Compilers Principles, Techniques, and Tools

------

# —————2019/7/15—————

# 第三章：词法分析

本章讨论词法分析器的说明和实现技术。实现词法分析器的简单方法包括两步：首先建立一张描述源语言记号的结构的图，然后，手工地把这张图翻译成能够识别源语言记号的程序

这种技术也常用于其他领域，如查询语言与信息检索系统。在每个应用中，最基本的问题是==如何设计与说明一种特殊的程序，它能够完成由字符串中的模式触发的动作==

词法分析器的生成器的最大优点是它能利用最著名的模式匹配算法为那些不精通模式匹配技巧的人产生有效的词法分析器

## 3.1 词法分析器的作用

词法分析是编译的第一阶段。词法分析器的主要任务是读入输入字符，产生记号序列，提交给语法分析使用。这种交互通常可以通过使词法分析器作为语法分析器的子程序或协作程序来实现。当词法分析器收到语法分析器发出的”取下一个记号“的命令时，词法分析器读入输入字符，直到识别出下一个记号。

```mermaid
graph LR
subgraph 
    源程序 --> 词法分析器
    词法分析器 --记号--> 语法分析器
    语法分析器 --取下一个记号--> 词法分析器
    语法分析器 -.-> 下一步
    end
subgraph 
    词法分析器 --- 符号表 
    符号表 --- 语法分析器
    end
```

词法分析器是编译器中读入源程序的部分，因此它还可以完成一些相关的辅助任务。一个任务是滤掉源程序中的注释、空格、制表符、换行符；另一个任务是使编译器能将发现的错误信息与源程序的出错位置联系起来。如果源语言支持宏处理功能，可以在词法分析阶段完成这些预处理功能

有时，词法分析器可以分两阶段：第一个阶段是扫描阶段，第二个阶段是词法分析阶段。扫描程序负责完成一些简单的任务，词法分析器要完成比较复杂的任务

### 3.1.1 词法分析中的问题

把编译过程的分析阶段划分为词法分析和语法分析的原因如下：

1. 简化编译器的设计可能是最重要的考虑，词法分析和语法分析分离可以简化两者的设计
2. 提高编译器的效率。把词法分析独立出来使我们能构造更有效的专门的处理器。编译的大部分时间消耗在读源程序并将其切分为记号方面。采用专门的缓存技术来进行输入字符串的读取和记号的处理可以显著地提高编译器的性能
3. 增强编译器的可移植性。与设备有关的特征以及语言的字符集的特殊性的处理可以被限制在词法分析器中，不会影响编译器其他部分的设计

### 3.1.2 记号、模式、词素

通常，在输入中有一组字符串会产生相同的==记号==（作为输出），这个字符串构成的集合由一个与该记号相关联的称为==模式==的规则来描述。这个模式被说成==匹配==该集合中的每个字符串。==词素==是源程序的字符序列，由一个记号的模式来匹配

把记号作为源语言文法的终结符，用黑体名字表示记号。由记号的模式所匹配的词素表示源程序的字符串，它们是词法单位

在多数程序设计语言中，下列结构被处理为记号：关键字、操作符、标识符、常量、文字串和标点符号（如括号，逗号，分号）。==记号的返回通常是通过传递代表这个记号的整数来实现的==

模式是描述源程序中表示特定记号的词素集合的规则

某些语言的约定给词法分析带来了困难。例如Fortran语言要求某些结构出现在输入行的固定位置，于是**词素对准alignment**对确定源程序的正确性非常重要。现代语言设计的倾向是自由格式输入，允许各种结构出现在输入行的任何地方。因此这个问题在词法分析中不再是重要的了

不同的语言在空格的处理上有较大的差别

很多语言规定某些字符串是保留的，即它们的含义是预定义的，不能由用户改变。如果关键字不是保留的，那么词法分析器必须能区分出关键字和用户自定义的标识符。在PL/I语言中关键字不是保留的，因而把关键字从标识符中区别出来的规则相当复杂

### 3.1.3 记号的属性

如果一个记号的模式能匹配不止一个词素，词法分析器必须为这个记号提供附加的关于匹配的特殊词素的信息。词法分析器把与记号有关的信息收集到记号的属性中。==记号影响语法分析，而属性影响记号的翻译==。==在实际实现时，记号通常只有一个属性，即指向符号表中一个表项的指针，与记号有关的信息保存在这个对应的表项中==。为了诊断错误，我们不仅需要知道匹配标识符的词素，而且还需要知道这个词素第一次出现的行号。这些信息都可以存储在符号表中该标识符对应的表项内

记号和它们的属性可以用二元组序列表示，某些二元组不需要属性值，它的第一个分量足以标识词素

### 3.1.4 词法错误

因为词法分析器不能从全局的角度考察源程序，所以能在词法层发现的错误是有限的

如果遇到fi，它无法区别fi究竟是关键字if的错误拼写还是一个未声明的函数标识符。由于fi是合法的标识符，词法分析器必须返回该标识符的记号，而让编译器的其他阶段去处理这种错误

==有时会出现由于剩余输入的前缀不能和任何记号的模式匹配而使词法分析器无法处理的情况。此时，最简单的错误恢复策略也许是”紧急方式“恢复，即反复删掉剩余输入最前面的字符，直到词法分析器能发现一个正确的记号为止==。这种恢复技术可能会给语法分析带来一些麻烦，但在交互计算环境中是非常有效的

其他错误恢复动作包括：1.删除一个多余的字符；2.插入一个遗漏的字符；3.用一个正确的字符代替一个不正确的字符；4.交换两个相邻的字符

这样的错误变换可以用于对输入错误的修补，最简单的策略是看一下剩余输入的前缀能否通过上面的一个变换变成一个合法的词素。这种策略假设大多数词法错误是多、漏或错了一个字符或者相邻的两个字符错位的结果。事实上，这种假设通常（但不总是）是正确的

在程序中发现错误的一种方法是计算把一个错误程序转换成一个语法上正确的程序所需要的错误变换个数的最小值。当把一个错误程序转换成一个正确程序所需的最短的错误变换序列长度为k时，我们说这个程序有k个错误。最小距离错误校正是一种理论上的标准，但因其实现起来代价太高，实际上并不常用。然而，一些试验性的编译器在进行局部校正时确实用到了最小距离标准

## 3.2 输入缓冲

一种双缓冲输入方案，这种方案在为识别记号而需要进行超前扫描的情况下非常有用。一些其他提高词法分析器效率的技术，如使用**标志sentinel**标记缓冲区边界

实现词法分析器最常用的三种方案如下：1. 使用词法分析器生成器，从基于正规表达式的说明自动产生一个词法分析器。在这种情况下，由生成器提供子程序实现输入流的读取和缓冲；2. 使用传统的程序设计语言编写词法分析器，并使用该语言提供的IO功能对输入流进行读取；3. 使用汇编语言编写词法分析器，并显式地控制输入流的读取

==词法分析器是编译器中唯一的逐个字符读取源程序的阶段，所以他可能会耗费大量的时间，因此，在设计编译器时，词法分析器的速度是一个关键因素==

### 3.2.1 双缓冲区

对很多源语言来说，在一个词素被一个模式匹配上之前，词法分析器往往需要超前扫描该词素后面的若干字符，第二章中的ungetc函数将超前扫描的字符退回到输入流中，然而，这种方法需要大量的移动字符时间。人们开发出一些特殊的缓冲技术以减少这种时间开销，但是这些缓冲技术在某种程度上依赖于系统的参数，因而，本书只能简单地介绍一下这类技术的原理

把一个缓冲区分成两个部分，每部分能容纳N个字符，一般来说，N是一个磁盘块中字符的个数，如1024或4096

每次用一个系统读命令向缓冲区的每半部分读入N个字符，而不是每读入一个字符调用一次读命令。如果剩余的输入数据不足N个字符，则在缓冲区最后一个字符后面会读进来一个特殊字符eof，eof不同于任何其他的输入字符，它用于标识源文件的结尾

输入缓冲区包括两个指针，在两个指针之间的字符串就是当前的词素。一开始，两个指针都指向下一个要识别的词素的第一个字符上。然后，其中一个指针（即向前forward指针）向前扫描，直到发现一个与某个模式匹配的词素为止，一旦一个词素被确定，向前指针将指向它的最右字符，在处理完这个词素后，两个指针同时定位到这个词素的一个字符。在这种策略中，注释和空白符可以由不生成记号的模式来匹配

如果向前指针将要移过缓冲区的中间标记，则往缓冲区的右半部读入N个新字符，如果向前指针将要移过缓冲区的右端，则往其左半部读入N个新字符，且将向前指针绕回到缓冲区的头部继续处理

这种缓冲机制在多数情况下都非常有效，但限制了超前扫描的数量，在超前扫描时，若向前指针需要移动的距离超过了缓冲区的长度，词法分析器就无法识别出记号

例如：在扫描到某个词的参数的右括号后面的字符之前，是无法确定这个词是关键字还是数组名称。在这两种情况下，词素都在这个词字符结束处结束，需要==超前扫描的字符数量与参数个数成正比==，而参数个数在原则上是不限制的

### 3.2.2 标志

双缓冲区模式，在每次移动向前指针时都必须检查是否到了缓冲区某半部分的末尾，若是，则需要重装缓冲区的另半部分

在缓冲区两部分的结尾处各设置一个标志字符，则可以减少一次测试。这个“标志”必须是源语言词素集合的特殊字符，一个比较自然的选择就是eof

```c
forward := forward + 1
if ↑forward := eof then begin
    if forward在第一部分末尾 then begin
        重装第二部分;
        forward := forward + 1
    end
    else if forward在第二部分末尾 then begin
        重装第一部分
        将forward移到第一部分开始
    end
    else /*eof在表示输入结果的缓冲区中*/
        终止词法分析
end
```

如上，在大部分情况下，算法只需测试一次，以判断forward指针是否已经指向eof，只有当到达缓冲区半部分的末尾或源文件尾时，算法才需要进行更多的测试，==由于在两个eof之间有N个字符，每个输入字符的平均检查次数近似于1==（没懂？怎么算的？）

还需要确定如何处理向前指针当前所指的字符，该字符可能是一个记号的结尾标志，也可能是正被识别的关键字的一部分，还可能是其他各种情况。如果所选的实现语言支持case语句，则可以用它来完成这些测试

## 3.3 记号的描述

正规表达式是表示模式的一种重要方法。每个模式匹配一个字符串集，因此正规表达式将作为字符串集的名字

### 3.3.1 串和语言

术语**字母表**或**字符类**表示有限符号的集合。字母表上的**字符串**是该字母表中符号的有穷序列。在语言理论中，术语**句子**和**字**常作为“符号串”的同义词。符号串s的长度是出现在s中的符号的个数，通常记作|s|。例如banana是长度为6的符号串，空字符串是长度为0的特殊符号串，用ε表示

s的子序列是从串s中删除0个或多个符号后得到的串，这些被删除的符号可以不相邻，例如，baaa是banana的子序列

**语言**是给定字母表上的任意一个字符串集合，这个定义是广义的，像**空集**和仅包含空符号串的集合{ε}这样的抽象语言也符合这个定义，所有语法正确的Pascal程序的集合和所有语法正确的英语句子的集合也符合此定义。当然，要描述后两个集合要难得多

如果x和y是符号串，那么x和y的**连接**（记作xy）是把y连接到x后面所形成的符号串，对连接运算而言，空符号串是一个单位元，也就是说，sε = εs = s

如果把两个符号串的连接看成是这两个串的乘积，可以定义符号串的指数如下：定义s^0为ε，对于i>0，s^i为s^(i-1)s，因为εs是s本身，所以s^1=s, s^2=ss, s^3=sss，以此类推

### 3.3.2 语言上的运算

对词法分析而言，我们感兴趣的是并、连接和闭包运算

L的克林Kleene闭包，记作`L*`，表示0个或多个L的连接
L的正闭包，记作`L+`，表示1个或多个L的连接

### 3.3.3 正规表达式

`L(L∪D)*`是所有以字母开头的字母数字串的集合。用正规表达式的表示法可以定义为`letter(letter|digit)*`

建立正规表达式时，可先定义简单的正规表达式，然后用它们构造出更复杂的正规表达式。每个正规表达式r表示一个语言L(r)。这些定义规则说明L(r)是怎样由r的子表达式所表示的语言以不同的方式组合形成的。

下面是**定义字母表∑上的正规表达式**的规则，每一条规则后带有所定义的正规表达式所表示的语言的一个说明

1. ε是正规表达式，它表示{ε}，即包含空串的集合
2. 如果a是∑上的符号，那么a是正规表达式，表示{a}，也就是包含符号串a的集合
3. 假定r和s都是正规表达式，分别表示语言L(r)和L(s)，则：
   1. `(r)|(s)`是正规表达式，表示`L(r)∪L(s)`
   2. `(r)(s)`是正规表达式，表示`L(r)L(s)`
   3. `(r)*`是正规表达式，表示`(L(r))*`
   4. `(r)`是正规表达式，表示`L(r)`

正规表达式表示的语言叫做**正规集**。我们把ε和出现在正规表达式中的∑中的符号称为**基本符号**

1. 一元运算符`*`具有最高的优先级，并且是左结合的
2. 连接的优先级次之，也是左结合的
3. |的优先级最低，同样是左结合的

`*`和ε的关系：`r* = (r|ε)*`，`*`是幂等的`r** = r*`

### 3.3.4 正规定义

为表示方便，我们为正规表达式命名，并用这些名字来定义正规表达式，就如同它们也是符号一样。如果∑是基本符号的字母表，那么**正规定义**是如下形式的定义序列：d1 → r1	d2 → r2	...	dn → rn

其中，每个di都是一个名字，并且它们各不相同，每个ri是∑∪{d1, d2, ..., di-1}（即基本符号和前面定义的名字）中符号上的正规表达式。由于限制了每个ri中只含有∑中的符号和在它之前定义的名字，所以我们可以通过反复地用名字所代表的正规表达式替代该名字的方法为任何一个ri构造∑上的正规表达式。如果ri用到了dj，并且j>=i，则ri是递归定义的，而且这个替换过程不会中止

例：
**letter** → A|B|...|Z|a|b|...|z
**digit** → 0|1|...|9
**id** → **letter** ( **letter** | **digit** )*

例：
**digit** → 0|1|...|9
**digits** → **digit** **digit***
**optional_fraction** → . **digits** | ε
**optional_exponent** → ( E ( + | - | ε ) **digits** ) | ε
**num** → **digits** **optional_fraction** **optional_exponent**

### 3.3.5 缩写表示法

在正规表达式中，某些结构出现频繁，为方便起见，可以用缩写形式来表示它们

1. 一个或多个实例，一元后缀操作符+的意思是一个或多个实例。操作符+和操作符`*`具有同样的优先级和结合性，代数恒等式`r*=r+|ε`与`r+=rr*`表达了克林闭包`*`和正闭包+这两个操作符间的关系
2. 零个或一个实例，一元后缀操作符?的意思是“零个或一个实例”。r?是r|ε的缩写形式
3. 字符类，[abc]（其中a、b和c是字母表中的符号）表示正规表达式a|b|c，缩写的字符类[a-z]表示正规表达式a|b|...|z。可以使用下述正规表达式描述标识符：`[A-Za-z][A-Za-z0-9]*`

### 3.3.6 非正规集

某些语言不能用正规表达式描述：

正规表达式不能用于描述均衡或嵌套结构。例如，具有配对括号的符号串集合不能用正规表达式描述，但它们可以用上下文无关文法来描述

重复符号串不能用正规表达式表示，集合（wcw|w是a和b组成的串）不能用正规表达式描述，也不能用上下文无关文法来说明

正规表达式只能表示固定次数的重复或给定结构的没有指定次数的重复。由于正规表达式不能比较任意两个数是否相等

## 3.4 记号的识别

**delim** → **blank** | **tab** | **newline**
**ws** → **delim**+

如果发现了与ws匹配的字符串，则词法分析器不返回记号给语法分析器，继续识别空白符后面的记号，然后把它返回给语法分析器

目标是构造一个词法分析器，这个词法分析器能在输入缓冲区中识别出下一个记号的词素，产生该词素相应的记号和属性值的二元组

### 3.4.1 状态转换图

状态转换图transition diagram描绘语法分析器为得到下一个记号而调用词法分析器时词法分析器要做的动作。假设**词素开始lexeme-beginning指针**指向上次发现的词素后面的字符。当向前指针扫描输入流字符时，我们用状态转换图来记录所读信息的轨迹，方法是在读字符的过程中我们不断地在状态转换图的各位置之间移动

状态转换图的位置用圆圈表示，叫做**状态**。状态间由箭头连接，称为**边**。由状态s到状态r的边上标记的字符表示使状态s转换到状态r的输入字符。标记other表示任意一个未被离开状态s的边所标定字符

状态转换图中具有一个状态标记为start状态，这个状态称为**初始状态**。识别记号时，我们将从这个状态开始。有些状态可以具有动作，当控制流到达一个具有动作的状态时，我们将执行这些动作。当进入一个状态时，我们需要读下一个输入字符，若存在一个离开当前状态的边，其标记和读入字符匹配，控制就转到由这条边指向的状态，否则表示失败

状态上的`*`表示向前指针必须回退一个字符

通常可能有多个状态转换图，每个图说明一组记号，如果沿着一个状态转换图识别输入字符串时失败，我们需要把向前指针回退到进入该图开始状态时该指针所指向的输入字符串位置，并启动下一个状态转换图。因为在状态转换图的开始状态，词法分析器的词素开始指针和向前指针都指向同一个位置，所以向前指针被回退到词素开始指针所指向的位置。如果我们在所有状态转换图上都失败了，则意味着输入字符串有词法错误，这时，我们需要调用错误恢复程序进行错误处理

==一般来说，我们不为关键字单独构造状态转换图==，而是把关键字看成特殊的标识符，在到达图的接受状态时，执行一段代码，以确定这次识别的词素是关键字还是标识符

把关键字从标识符中分离出来的一种简单技术是适当地初始化符号表

如果有要增加的关键字，无需修改状态转换图，只需将新增关键字对应的字符串和记号填入符号表即可

如果手工编写词法分析器，把关键字先放进符号表的技术是很重要的，如果不这样做，一个典型的程序设计语言的词法分析器的状态数会达到几百个，如果使用这种技术，需要的状态数可能不到一百个

**num** → **digit**+ ( .**digit**+ )? (E(+|-)? **digit**+)?

一个给定记号的词素必须是最长的，例如，当输入串是12.3E4时，词法分析器不应该在发现12或12.3后就停止

有关不符合记号正规定义语言的信息可以用来指出输入的错误，希望能够指出这个错误并继续执行，这些想法也可以用来简化状态转换图，因为错误处理可以使某些导致失败的错误得到恢复

可以使用多种方法避免多余匹配。一种方法是将这些状态转换图合并成一张图，一般来说这个任务比较艰巨，另一种方法是改变对失败的响应策略，

进行匹配时，首先尝试编号小的开始状态，然后尝试编号大的开始状态

识别ws的状态转换图在到达接受状态时，什么也不返回，只是回到第一个状态转换图的开始状态，寻找其他模式

只要有可能，先寻找出现频率较高的记号比较有利，因为只有前面所有的状态转换图都匹配失败以后，才会到达下一个状态转换图。空白符肯定是经常出现的，所以把识别空白符的状态装换图放在较前面将有利于提高效率

### 3.4.2 状态转换图的实现

状态转换图序列可以变换成程序，用来识别该序列所定义的记号。每个状态对应一个代码段，如果一个状态具有出边，该状态的代码便读一个字符并选择应跟随的边，函数nextchar()用来从输入缓冲区中读入下一个字符，每次调用都向前移动向前指针，并返回读入的字符。如果存在标记为该字符的边，或标记为包含该字符的字符类的边，则控制转给这条边指向的状态所对应的代码。如果不存在这样的边，而且当前状态不是接受状态，==调用fail()程序，把向前指针撤回到开始指针指向的位置==，启动下一个状态转换图对应的代码继续匹配。如果不存在下一个状态转换图，fail()调用错误恢复程序，进行错误处理

使用case语句来查找下一个状态转换图的开始状态

```c
int state = 0, start = 0;
int lexical_value;
	/* 返回记号的第二个分量 */
int fail()
{
    forward = token_beginning;
    switch (start) {
        case 0:    start = 9; break;
        case 9:    start = 12; break;
        case 12:    start = 20; break;
        case 20:    start = 25; break;
        case 25:    recover(); break;
        default:    /* 编译错误 */
    }
    return start;
}
```

在状态转换图中一条边一条边地往下匹配的过程是通过不断地选择一个状态对应的代码段来执行，以确定出下一个状态，并将控制转到该状态对应的代码段去执行

```c
token nexttoken()
{
    while(1) {
        switch (state) {
            case 0:    c = nextchar();
                /* c是超前扫描字符 */
                if (c==blank || c==tab || c==newline) {
                    state = 0;
                    lexeme_beginning++;
                        /* 词素开始指针的前移 */
                }
                else if (c == '<') state = 1;
                else if (c == '=') state = 5;
                else if (c == '>') state = 6;
                else state = fail();
                break;
                .../* 这里放cases 1~8 */
            case 9:    c = nextchar();
                if (isletter(c)) state = 10;
                else state = fail();
                break;
            case 10:    c = nextchar();
                if (isletter(c)) state = 10;
                else if (isdigit(c)) state = 10;
                else state = 11;
                break;
            case 11:    retract(1); install_id();
                return ( gettoken() );
                /* retract(1)是撤回一个字符的意思 */
                .../* 这里放case 12~24 */
            case 25:    c = nextchar();
                if (isdigit(c)) state = 26;
                else state = fail();
                break;
            case 26:    c = nextchar();
                if (isdigit(c)) state = 26;
                else state = 27;
                break;
            case 27:    retract(1); install_num();
                return ( NUM );
                /* retract(1)是撤回一个字符的意思 */
        }
    }
}
```

如果实现状态转换图的语言没有case语句，可以为每个状态创建一个数组，用字符作下标，如果state1是这样的数组，则当超前扫描的字符是c时，state1[c]是指向需要执行的程序段的指针。这些代码段一般以转到下一个状态的代码段的goto语句结束。状态s的数组可以看成是s的间接状态转换表

## 3.5 词法分析器描述语言

目前有很多基于正规表达式从特定表示法构建词法分析器的工具

一个叫做Lex的工具，已经广泛地应用于各种语言的词法分析器的描述，称这种工具为**Lex编译器**，Lex编译器的输入称为**Lex语言**

任何把正规表达式描述的模式与行为结合起来

Lex的使用方法通常为，首先使用Lex语言写一个定义词法分析器的源程序lex.l。然后，利用Lex编译器将lex.l转换成C语言程序lex.yy.c。它包括从lex.l的正规表达式构造的状态转换图的表格形式以及使用该表格识别词素的标准子程序。==与lex.l中正规表达式相关联的动作是C代码段，这些动作可以直接加到lex.yy.c中==，最后，lex.yy.c通过C编译器生成目标程序a.out，a.out就是把输入流转换成记号序列的词法分析器

### 3.5.1 Lex说明

由Lex创建的词法分析器与语法分析器协同工作的方式如下：词法分析器被语法分析器调用后，从尚未扫描的输入字符串中读字符，每次读入一个字符，直到发现能与某个正规表达式pi匹配的最长前缀，然后，词法分析器执行actioni。通常actioni会将控制返回给语法分析器，然而，如果不将控制交给语法分析器，词法分析器可以继续发现更多的词素，直到某个操作将控制返回给语法分析器。词法分析器的这种不断查找词素，直到以显式的return调用结束工作的方式，使其可以方便地处理空白符和注释

词法分析器只返回记号给语法分析器，带有与词素相关信息的属性值是通过全局变量yylval传递的

Lex程序组成

声明部分
%%
转换规则
%%
辅助过程

转换规则是如下形式的语句
p1 { action1 }
p2 { action2 }
...
pn { actionn }

在声明部分，转换规则所使用的符号常量的声明，也可以由语法分析器定义。由一对特殊括号%{和%}括在一起，所有出现在括号内的内容都直接复制到词法分析器lex.yy.c中。辅助过程也进行同样的处理

小数点表示为`\.`在Lex和很多UNIX系统的处理正规表达式的程序中，单独的一个点表示除了换行符以外的所有字符的字符类

如果一条规则识别出if，则返回记号IF，它是表示某个整数的符号常量，语法分析器将这个整数理解为记号if

通常，采用将匹配关键字的模式置于匹配标识符的模式之前的策略，可以简单有效地保留关键字==（之前说的不是通过符号表看符号表返回的是什么嘛）==

#### ==调用fail()程序，把向前指针撤回到开始指针指向的位置==，启动下一个状态转换图对应的代码继续匹配

Lex采用==“选择最长匹配前缀的策略”==方便地解决了<和<=之间的冲突

### 3.5.2 超前扫描操作

对于某些程序设计语言结构，词法分析器需要超前扫描词素后面的若干字符来确定一个记号，Lex中可以把模式协程r1/r2的形式，其中r1、r2都是正规表达式。当一个字符串r1匹配时，还需其后的字符串与r2匹配，这样才算该字符串与r1匹配成功，r2表示需要进一步匹配的内容，这里只是匹配模式的一个限制，而不是匹配的一部分

对Fortran程序进行词法分析是很不规则的任务，使用特殊的程序设计语言直接编写Fortran词法分析器比使用自动生成器来生成词法分析器更容易

## 3.6 有穷自动机

语言的**识别器**是一个程序，以字符串x作为输入，当x是语言的句子时，回答是，否则不是。可以通过构造有穷自动机把正规表达式编译成识别器。有穷自动机是更一般化的状态转换图，它可以是确定的或不确定的，其中“不确定”的含义是：对于某个输入符号，在同一个状态上存在不止一种转换

确定和不确定的有穷自动机都能而且仅能识别正规集，即它们能够识别正规表达式所表示的语言。但是，它们之间有着时空的权衡。确定的有穷自动机导出的识别器比不确定的有穷自动机导出的识别器快得多，但确定的有穷自动机可能比与之等价的不确定的有穷自动机大得多

下面的基本例子是由正规表达式`(a|b)*abb`表示的语言

### 3.6.1 不确定的有穷自动机

简写为NFA，是一个由以下几部分组成的数学模型：

1. 一个状态的有穷集合S
2. 一个输入符号集合∑，即输入符号字母表
3. 一个转换函数move，它把由状态和符号组成的二元组映射到状态集合
4. 状态s0是唯一的开始或初始状态
5. 状态集合F是接收（或终止）状态集合

NFA可以用带标记的有向图表示，称为**转换图transition graph**，其节点是状态，有标记的边表示转换函数。这种转换图和前面的**状态转换图transition diagram**很类似，但略有不同：同一个字符可以标记始于同一个状态的两个或多个转换，边可以由输入字符符号，也可以由特殊符号ε标记

可以在计算机上使用不同的方法实现NFA的转换函数，最简单的办法是使用**转换表**，表中第i行a列对应的表项是当输入为a时从状态i所能到达的状态的集合

转换表表示的优点是能够快速地确定给定状态在给定字符上的转换，它的缺点是：当输入字母表较大而且大多数转换是空集时，需要耗费大量空间。

当且仅当对应的转换图中存在从开始状态到某个接受状态的路径，使得该路径的边上的标记恰好连成字符串x时，一个NFA接受输入字符串x

一条路径可以用状态转换序列表示，其中的状态转换叫做移动。一般来说，可能有多个移动序列可以到达接受状态。也许还可以沿着一些其他的移动序列走下去，但它们都不会终止在接受状态

由NFA定义的语言是它接受的输入字符串的集合

### 3.6.2 确定的有穷自动机

简称DFA，是不确定的有穷自动机的特例

1. 没有一个状态具有ε转换，即在输入ε上的转换
2. 对每个状态s和输入符号a，最多只有一条标记为a的边离开s

确定的有穷自动机在任何状态下，对任一输入符号，最多只有一个转换，如果用转换表表示DFA的转换函数，那么表中的每个表项最多只要一个状态，因为，很容易确定DFA是否接受某输入字符串

#### 算法3.1 模拟DFA

输入：输入以文件结束符eof结尾的串x，一个DFA D，其开始状态为s0，接受状态集合为F

输出：如果D接受x，则回答yes，否则回答no

```c
s := s0;
c := nextchar;
while c != eof do
    s := move(s, c);
	c := nextchar
end;
if s is in F then
	return "yes"
else return "no";
```

### 3.6.3 从NFA到DFA的变换

当在某一个状态上既可以根据ε也可以根据一个实际的输入符号进行转换时，会引起歧义，这种多值转换函数使我们很难用计算机程序模拟NFA

如果有很多路径其边上的标记都可以连成同样的输入字符串，则在找到一条接受路径或发现没有路径可达到接受状态前，可能不得不考虑所有这些路径

现在给出NFA构造识别同样语言的DFA的算法：这个算法通常被称为**子集构造算法**，它有利于使用计算机程序模拟NFA

从NFA变换到DFA的基本思想是让DFA的每个状态对应NFA的一个状态集，这个DFA用它的状态去记住NFA在读输入符号后到达的所有状态。也就是说，在读了输入a1a2...an后，DFA到达一个代表NFA的状态子集T的状态，这个子集T是从NFA的开始状态沿着那些标有a1a2...an的路径能到达的所有状态的集合。==DFA的状态数有可能是NFA状态数的指数==，但实际上，这种最坏的情况很少发生

#### 算法3.2 (子集构造算法) 从NFA构造DFA

输入：一个NFA N

输出：一个接受同样语言的DFA D

方法：为D构造转换表Dtran，DFA的每个状态是NFA的状态集，D将“并行”地模拟N对输入串的所有可能的移动

D的每个状态对应于NFA的一个状态集，它是N读了某个输入符号序列后所能到达的全部状态，包括所有的ε转换。如果D的某个状态是至少包含一个N的接受状态的NFA状态集，那么它是D的一个接受状态

子集构造法

```c
初始时，ε-closure(s0)是Dstates中唯一的状态且未被标记;
while Dstates中存在一个未标记的状态T do begin
	标记T:
	for 每个输入符号a do begin
		U := ε-closure(move(T, a));
		if U没在Dstates中 then
			将U作为一个未标记的状态添加到Dstates中;
		Dtran[T, a] := U
	end
end
```

ε-closure的计算

```c
将T中所有的状态压入栈stack中;
将ε-closure(T)初始化为T;
while 栈stack不空 do begin
	将栈顶元素t弹出栈;
	for 每个这样的状态u: 从t到u有一条标记为ε的边 do
        if u不在ε-closure(T)中 do begin
        	将u添加到ε-closure(T);
			将u压入栈stack中
		end
end
```

因为包含11个状态的集合其不同子集“只有”2^11个，而且一个集合一旦被标记就永远是标记的，所以这个过程肯定能终止

## 3.7 从正规表达式到NFA==（不太懂）==

有很多从正规表达式建立其识别器的策略，各有优劣。其中一个策略常用于文本编辑程序

### 3.7.1 从正规表达式构造NFA

这个算法有很多变形。本节是一个易于实现的简单版本，这个算法是语法制导算法，该算法使用正规表达式的语法结构来制导构造过程。算法的分支遵循正规表达式定义的分支。首先构造自动机使其能够识别ε和字母表中任何符号，然后由此构造自动机来识别包含一个交换、一个连接或一个克林闭包运算符的正规表达式

在构造过程中，每步最多引入两个新的状态，于是，为一个正规表达式构造的最终NFA的状态数最多两倍于该正规表达式中符号和操作符数

#### 算法3.3 （Thompson构造法）从正规表达式构造NFA

输入：字母表∑上的一个正规表达式r

输出：接受L(r)的NFA N

方法：首先，分析r并将其分解成最基本的子表达式，然后使用下面的规则1和规则2为r中的每个基本符号（ε或字母表中的符号）构造NFA。基本符号对应正规表达式定义的1和2两部分。==请注意，如果符号a在r中出现多次，则要为它的每次出现构造一个NFA=。然后，由正规表达式r的语法结构制导，用下面的规则3逐步地组合前面构造的NFA，直到获得整个正规表达式的NFA为止。在构造过程中所产生的中间NFA（与r的子表达式对应）有几个重要的性质：只有一个终态；开始状态无入边，终态无出边

1. 其中，i是新的开始状态，f是新的接受状态。很明显这个NFA识别{ε}

2. 对于Σ中的每个符号a，构造NFA

   ![1563347604932](../../../../AppData/Roaming/Typora/typora-user-images/1563347604932.png)

   其中，i是新的开始状态，f是新的接受状态。很明显这个NFA识别{a}

3. 如果N(s)和N(t)是正规表达式s和t的NFA，则

   1. 对于正规表达式s|t，可构造复合的NFA N(s|t)如下

      ![1563347588492](../../../../AppData/Roaming/Typora/typora-user-images/1563347588492.png)

      这里i是新的开始状态，f是新的接受状态，N(s)和N(t)的开始和接受状态不是N(s|t)的开始和接受状态。这样，从i到f的任何路径必须独立完整地通过N(s)或N(t)，因此这个复合的NFA识别L(s)∪L(t)

   2. 对于正规表达式st，可构造复合的NFA N(st)如下
      ![1563347574830](../../../../AppData/Roaming/Typora/typora-user-images/1563347574830.png)

      这里N(s)的开始状态成为复合NFA的开始状态，N(s)的接受状态和N(t)的开始状态合并，也就是说N(t)的开始状态上的所有转换现在变成了N(s)的接受状态上的转换。合并后的状态不作为复合后的NFA的接受或开始状态。从i到f的路径必须首先经过N(s)，然后经过N(t)，所以路径上的标记是L(s)L(t)中的串，因为没有边进入N(t)的开始状态或离开N(s)的接受状态，所以从i到f的路径不能从N(t)回到N(s)，因此复合的NFA识别L(s)L(t)

   3. 对于正规表达式`s*`，可构造复合的NFA N(`s*`)如下
      ![1563347557607](../../../../AppData/Roaming/Typora/typora-user-images/1563347557607.png)

      i和f分别是新的开始状态和接受状态

   4. 对于括起来的正规表达式(s)，使用N(s)本身作为它的NFA

=在上述构造过程中，每次构造的新状态都要赋予不同的名字==。这样，任何NFA的两个状态都具有不同名字，即使同一符号在r中出现多次，也要为该符号的每个实例创建一个独立的带有自己状态的NFA

产生的NFA具有下列性质：

1. N(r)的状态数最多是r中符号和运算符个数的两倍，因为构造的每步最多引入两个新状态
2. N(r)只有一个开始状态和一个接受状态，接受状态没有出边，作为构成成分的每个自动机也具有这一性质
3. N(r)的每个状态或者有一个用∑中的符号标记的出边，或者至多有两个标记为ε的出

### 3.7.2 NFA的双堆栈模拟

给出一个算法，对于给定的由算法3.3生成的NFA N和输入串x，判断自动机N是否能够接受字符串x。算法每次从输入字符串读取一个字符，然后计算自动机N在读入输入字符串的每个前缀后可能进入的所有状态的集合。这个算法的运行时间和|N|x|x|成正比，其中，|N|表示N的状态数，|x|表示串x的长度

#### 算法3.4 模拟NFA

输入：由算法3.3生成的NFA N和输入串x。假定输入串x由字符eof做结束标记，N以状态s0为开始状态，F是接受状态集

输出：如果N接受x，返回yes，否则返回no

方法：这个算法在运行时执行了**子集构造算法**，它分两步计算从当前状态集到下一个状态集的转换。第一步，它先求move(S, a)，即状态S在输入a（当前输入字符）上经过一个转换能到达的所有状态的集合。第二步求出move(S, a)在经过0个或多个ε转换后能到达的状态集

```c
S := ε-closure({s0});
a := nextchar;
while a != eof do begin
	S := ε-closure(move(S, a));
	a := nextchar
end
if S∩F != 空集 then
	return "yes";
else return "no";
```

算法3.4可以使用两个堆栈和由NFA状态做索引的位向量来有效地实现。一个堆栈用于跟踪非确定状态的当前集合的轨迹，另一个堆栈用于计算下一个非确定状态集。用位向量可以在在常数时间内判断一个非确定状态是否已在堆栈中，以防重复加入。一旦已经在第二个栈求出了下一个状态，则两个栈的角色互换

用|N|表示N的状态数，因为一个栈中至多有|N|个状态，所以计算当前状态集的下一个状态集的时间与|N|成正比，因此，模拟N在输入字符串x上的行为需要的时间正比于|N|x|x|

---

# ==这里需要说明一下==

#### DFA中

```c
for 每个输入符号a do begin
```

#### NFA中

```c
a := nextchar
```

---

### 3.7.3 时间空间的权衡

给定一个正规表达式r和输入字符串x，我们已经介绍了两种方法来确定x是否在L(r)中，第一种方法是利用算法3.3为r构造一个NFA N，时间复杂度是O(|r|)，其中|r|是r的长度，N至多具有两倍于|r|的状态，每一个状态至多有两个转换，因此N的转换表的空间复杂度是O(|r|)。使用算法3.4判断N是否接受字符串x，时间复杂性是O(|r|x|x|)。==在很多文本编辑器中，当目标字符串x不是很长时，可用这种方法寻找正规表达式模式==

第二种方法是先用Thompson构造法（算法3.3）从正规表达式r构造器NFA，然后再用子集构造法（算法3.2）构造DFA。利用转换表实现状态转换函数，并使用算法3.1模拟DFA在输入串x上的动作。这个算法时间代价与x的长度成正比，但与DFA的状态数无关，这种方法经常用于在文本文件中寻找正规表达式模式的模式匹配程序。一旦有穷自动机创建成功，查找的速度将非常快，当目标串x非常长时，这种方法是很有利的

#### ==个人理解==

大概意思是说，两种方法，一种是边读边找状态，另一种是先找出状态，再读

然而，存在一些正规表达式，它们的最小DFA也有很多的状态，其状态数是正规表达式大小的指数。例如，正规表达式`(a|b)*a(a|b)(a|b)...(a|b)`包含n-1个`(a|b)`，则识别该正规表达式的任意DFA的状态数不可能少于2^n。不难证明这个正规表达式的任何一个DFA都必须记忆输入字符串的最后n个字符的轨迹。虽然在一些应用中会出现类似的正规表达式，但幸运的是，在词法分析应用中，这种情况并不经常出现

另一种方法是使用DFA，但通过利用“惰性转换计算”技术来避免创建整个状态转换表。转换是在运行时计算的，只有在真正需要的时候才去计算给定状态在给定输入上的转换。计算的转换存储在cache中，每次要进行状态转换时，先检查cache，如果需要的转换不在cache中，才去

| 自动机 | 空间       | 时间           |
| ------ | ---------- | -------------- |
| NFA    | O(\|r\|)   | O(\|r\|x\|x\|) |
| DFA    | O(2^\|r\|) | O(\|x\|)       |

惰性技术结合了NFA的空间需求小和DFA的事件需求小的特点，他的空间需求是正规表达式的大小加上cache的大小，它的运行时间几乎与DFA识别器相同，在某些应用中，“惰性”技术比DFA方法还要快，因为它没有计算不必要的状态

## 3.8 设计词法分析器的生成器==（不懂）==

问题是怎样构造一个在输入缓存区中查找词素的识别器，如果有多个模式匹配成功，识别器将选择与最长词素匹配的模式。如果有多个模式与最长词素匹配，则选择第一个与最长词素匹配的模式

有穷自动机是一种创建词法分析器的自然模型，由Lex编辑器构造出的词法分析器有一个输入缓冲区，Lex编辑器根据使用Lex说明书写的正规表达式模式为有穷自动机构造转换表。词法分析器本身包括一个有穷自动机模拟器，这个模拟器使用转换表在输入缓冲区中查找正规表达式模式

==这里的的转换表指的是状态转换表==

由正规表达式生成的NFA的转换表远小于DFA的转换表，但进行模式匹配时DFA比NFA要快得

### 3.8.1 基于NFA的模式匹配

一种基于NFA的模式匹配方法是为模式p1|p2|...|pn的NFA N构造状态转换表。首先使用算法3.3为每个模式pi构造NFA N (pi)，然后加入一个新的开始状态s0，并用ε转换将s0和每个N(pi)的开始状态相连。

我们构造一个状态集序列，其中每个状态集都是NFA看到每个输入字符后能够进入的状态集。即使在一个状态集中包括了一个接受状态，但为了实现最长的匹配，仍需要继续模拟NFA，穷尽当前输入符上的所有转换，即到达一个终止

每当给当前状态集加入一个接受状态时，我们要记录当前输入的位置和这个接受状态对应的模式pi。如果当前状态集已经包括了一个接受状态，那么只记录在Lex说明中先出现的那个模式

不断地进行状态转换直到遇到NFA进入终止。当进入终止时，把向前指针回退到最后一次匹配的位置，做出这个匹配的模式可以识别发现的记号，而且被匹配的词素是开始指针和向前指针之间的串

在Lex说明中与模式pi相关的动作actioni的作用如下：当识别出pi的一个实例时，词法分析器就执行相关联的程序action

---

#### ==这里有点不懂==

---

### 3.8.2 词法分析器的DFA

与上面描述的对NFA的模拟完全类似，只是在确定正确的模式匹配时有一些细微的差别。在一个非确定状态的子集中可能会有多个接受状态。在这种情况下，在Lex说明中位置靠前的模式对应的接受状态具有优先权，在穷尽对当前的输入符号的转换之前，还需要继续进行状态转换。

### 3.8.3 实现超前扫描操作

由于在某些情况下表示特定记号的模式可能需要描述实际词素后面的一部分正文，所以需要使用超前扫描操作符/。将一个含有/的模式转化为NFA时，可以将/看成是ε，使得我们不同真正地在输入字符串中查找/。当由这样的正规表达式表示的字符串在输入缓冲区中被识别出来时，词素的末尾并不在NFA的接受状态的位置上，而是在最后一个在（假象的）/上具有转换的状态上。需要返回到前面某个状态去寻找所识别的记号

## 3.9 基于DFA的模式匹配器的优化

### 3.9.1 NFA的重要状态

如果一个NFA的状态有一个标记为非ε的出边，则称这个状态是重要状态

### 3.9.2 从正规表达式到DFA

# ==看不懂了==

利用NFA的重要状态和正规表达式语法树的叶节点的等价性，我们可以绕过NFA的构造而直接构造一个其状态对应于语法树的位置集合的DFA

---

# ==看不懂了==

---

