# ==关于编译原理==

学了一半学不下去了，难度超级大，对数学水平要求高

学习编译原理基本上并不会在实际工作中进行实际的编译器的编写，编译器有一套严密的逻辑，并且现在手工实现一个完整的工业编译器不太现实，通常需要借助软件工具来实现

学习编译原理只是锻炼思维能力，锻炼对文字语言的处理算法

时间紧迫，直接学习操作系统吧，还需要学习数据结构和算法以及刷题

其他工具不着急，使用过一次就会掌握60%





---

# 网易公开课——清华大学公开课：操作系统

#### 共98集

---

## 1.1-1.8开场

操作系统OS，对应用程序为Shell，对硬件为Kernel，这门课主要讲Kernel

#### 操作系统四个特点：并发、共享、虚拟、异步

#### CPU调度器、物理内存管理、虚拟内存管理、文件系统管理、中断处理与设备驱动

现在完全看完一个操作系统的源码是一件不可能完成的任务，4500万行代码，把握整体

教材是落后于工业界的，IO这类问题所占的比重越来越小

---

## 2.1-2.2启动、中断、异常和系统调用

+ 启动
  计算机体系结构概述
  计算机内存和硬盘布局
  开机顺序
+ 中断、异常和系统调用
  背景
  中断、异常和系统调用相比较
  中断和异常处理机制
  系统调用的概念
  系统调用的实现
  程序调用与系统调用的不同之处
  开销

---

## 2.1操作系统的启动

---

#### 整个流程：

+ x86计算机刚通电时，从固定地址开始执行。CS:IP = 0xf000:fff0
+ 检查RAM、键盘、显示器、软硬磁盘
+ 将引导扇区的Bootloader读入内存的0x7c00处
+ Bootloader将硬盘中的OS读入内存并跳转执行

---

通电之后：CPU、内存、IO

DISK：存放OS
BIOS：基本I/O处理系统

#### BIOS是计算机的第一程序，==由硬件加载==（这里应该会把代码加载进内存的）

#### BIOS功能：通电后检测各种外设，加载相应软件

Bootloader：加载OS，也放在DISK上

#### 以x86为例，一开始加电，CPU从固定地址开始执行。CS:IP = 0xf000:fff0

CS：段寄存器；IP：指令寄存器，CS+IP形成一个内存地址

之后完成如下工作：

POST（加电自检）：寻找显卡和执行BIOS

BIOS再把Bootloader从DISK放在内存中0x7c00连续往上512字节。Bootloader放在硬盘的第一个扇区512字节

Bootloader加载OS

+ #### BIOS

  + 将Bootloader从磁盘的引导扇区（512字节）加载到0x7c00
  + 跳转到CS:IP = 0000:7c00

+ #### Bootloader

  + 将操作系统的代码和数据从硬盘加载到内存中
  + 跳转到操作系统的起始地址

---

#### 操作系统与设备和程序交互：接口的设计

定义

+ 系统调用（来源于应用程序）
  应用程序主动向操作系统发出服务请求
+ 异常（来源于不良的应用程序）
  非法指令或其他坏的处理状态（如：内存出错）
+ 中断（来源于外设）
  来自不同的硬件设备的计时器和网络的中断

应用程序不直接使用硬件：

+ 在计算机运行中，内核是被信任的第三方
+ 只有内核可以执行特权指令
+ 为了方便应用程序，提供简单一致的接口

---

## 2.2操作系统的中断、异常、系统调用

源头：

+ 中断：外设
+ 异常：应用程序意想不到的行为
+ 系统调用：应用程序请求操作提供服务

处理时间

+ 中断：异步
+ 异常：同步
+ 系统调用：异步或同步

响应

+ 中断：持续，对用户应用程序是透明的
+ 异常：杀死或者重新执行意想不到的应用程序指令
+ 系统调用：等待和持续

---

中断和异常的处理：由软件处理和硬件处理过程

中断和异常迫使CPU访问一些被中断和异常服务访问的功能

### 中断处理机制

#### 1. 硬件

+ 设置中断标记[CPU初始化]
  + 将内部、外部事件设置中断标记
  + 中断事件的ID

#### 2. 软件

+ 保存当前处理状态
+ 中断服务程序处理
+ 清除中断标记
+ 恢复之前保存的处理状态

### 异常处理机制

#### 1.异常编号

+ 保存现场
+ 异常处理
  + 杀死产生了异常的程序
  + 重新执行异常指令
+ 恢复现场

### 系统调用

+ 程序访问主要是通过高层次的API接口而不是直接进行系统调用
  + ==Win32 API==用于Windows
  + ==POSIX API==用于POSIX-based systems（包括UNIX、LINUX、Mac OS X的所有版本）
  + Java API用于JAVA虚拟机（JVM）
+ 通常情况下，与每个系统调用相关的序号
  + 系统调用接口根据这些序号来维护表的索引
+ 系统调用接口调用内核态中预期的系统调用
  + 并返回系统调用的状态和其他任何返回值
+ 用户不需要知道系统调用是如何实现的
  + 只需要获取API和了解操作新系统将什么作为返回结果
  + 操作系统接口的细节大部分都隐藏在API中
    + 通过运行程序支持的库来管理（用包含编译器的库来创建函数集）

用户态：应用程序执行中CPU特权级低

内核态：操作系统运行中CPU可以执行任何一条指令，包括特权指令

#### 系统调用和函数调用的区别

1. 堆栈切换
2. 特权级转换

#### ==系统调用的开销比函数调用的开销大，但也安全可靠正常运行==

#### 跨越操作系统边界的开销

+ 在执行时间上的开销超过程序调用
+ 开销（值得的必须的）：
  + 建立中断/异常/系统调用号与对应服务例程映射关系的初始化开销
  + 建立内核堆栈（操作系统使用自己的堆栈）
  + 验证参数
  + 内核态映射到用户态的地址空间，更新页面映射权限
  + 内核态独立地址空间，TLB

---



















