# 网易公开课——清华大学公开课：操作系统

---

+ 背景
  + CPU调度
  + CPU调度时间
+ 调度准则
+ 调度算法
+ 实时调度
+ 多处理器调度
+ 优先级反转

---

## 8.1背景

+ 上下文切换
  + 切换CPU的当前任务，从一个进程/线程到另一个
  + 保存当前进程/线程在PCB/TCP中的执行上下文（CPU状态）
  + 读取下一个进程/线程的上下文
+ CPU调度
  + 从就绪队列中挑选一个进程/线程作为CPU将要运行的下一个进程/线程
  + 调度程序：挑选进程/线程的内核函数（通过一些调度策略）
  + 什么时候进程调度？

---

+ 在进程/线程的生命周期中的什么时候进行调度
+ 内核运行调度程序的条件（满足一条即可）
  + 一个程序从运行状态切换到等待状态
  + 一个进程被终结了
+ 不可抢占
  + 调度程序必须等待事件结束
+ 可以抢占
  + 调度程序在中断被响应后执行
  + 当前的进程从运行切换到就绪，或者一个进程从等待切换到就绪
  + 当前运行的进程可以被换出

两种OS设计方式：用户态是否能抢占，内核态是否能抢占

早期OS不支持用户态的抢占，现在OS支持内核态的抢占

---

## 8.2调度原则

+ 调度策略
+ 程序执行模型
+ 比较调度算法的准则
+ 吞吐量vs延迟
+ 公平的目标

---

+ 执行模型：程序在CPU突发和I/O中交替
  + 每个调度决定都是关于在下一个CPU突发时将哪个工作交给CPU
  + 在时间分片机制下，线程可能在结束当前CPU突发前被迫放弃CPU

---

#### CPU使用率

+ CPU处于忙状态所占时间是百分比

#### 吞吐量

+ 在单位时间内完成的进程数量

#### 周转时间

+ 一个进程从初始化到结束，包括所有等待时间所花费的时间

#### 等待时间

+ 进程在就绪队列中的总时间

#### 响应时间

+ 从一个请求被提交到产生第一次响应所花费的总时间

---

#### 更快的服务

+ 传输文件时的高带宽
+ 玩游戏时的低延迟
+ 这两个因素是独立的

和水管类比

+ 低延迟：喝水的时候想要一打开水龙头水就流出来
+ 高带宽：给游泳池充水时希望从水龙头里同时流出大量的水，并且不介意是否存在延迟

---

+ 减少响应时间
  + 及时处理用户的输出并且尽快将输出提供给用户
+ 减少平均响应时间的波动
  + 在交互系统中，可预测性比高差异低平均更重要
+ 增加吞吐量——两个方面
  + 减少开销（操作系统开销，上下文切换）
  + 系统资源的高效利用（CPU，I/O设备）
+ 减少等待时间
  + 减少每个进程的等待时间

---

+ 低延迟调度增加了交互式表现
  + 如果移动了鼠标，但是屏幕中的光标却没动，可能会重启电脑
+ 但是操作系统需要保证吞吐量不受影响
  + 我想要结束长时间的编程，所以操作系统必须不时进行调度，即使存在许多交互任务
+ 吞吐量是操作系统的计算带宽
+ 响应时间是操作系统的计算延迟

---

+ 公平的定义

+ 举例
  + 保证每个进程占用相同的CPU时间
  + 这公平么？如果一个用户比其他用户运行更多的进程怎么办
+ 举例
  + 保证每个进程都等待相同的时间
+ 公平通常会增加平均响应时间

---

## 8.3-8.4调度算法

#### 一般系统常用的最简单的调度算法

+ FCFS 先来先服务 First Come, First Served
+ SPN(SJF) SRT 短进程优先(短作业优先) 和 短剩余时间优先 Shortest Process Next (Shortest Job First) Shortest Remaining Time（抢占与非抢占）
+ HRRN 最高响应比优先 Highest Response Ratio Next
+ Round Robin 轮循 使用时间切片和抢占来轮流执行任务
+ Multi Level Feedback Queues 多级反馈队列 优先级队列中的轮循
+ Fair Share Scheduling 公平共享调度

---

#### FCFS

+ FCFS队列的规定
  + 如果进程在执行中阻塞，队列中的下一个会得到CPU
+ 举例一 3个进程，计算时间分别为12,3,3
  + 任务到达顺序：p1, p2, p3
    周转时间Average response time = (12 + 15 + 18)/3 = 15
  + 任务到达顺序：p2, p3, p1
    周转时间Average response time = (3 + 6 + 18)/3 = 9
+ 优点
  + 简单
+ 缺点
  + 平均等待时间波动较大
  + 花费时间少的任务可能排在花费时间长的任务后面
  + 可能导致I/O和CPU之间的重叠处理
    + CPU密集型进程会导致I/O设备闲置时，I/O密集型进程也在等待

---

#### 短任务优先

+ 选择下一个最短的进程
  + 按照预测的完成时间来将任务入队
+ 可以是抢占的或者不可抢占的
  + 可抢占：又叫Shortest-Remaining-Time SRT 最短剩余时间
+ 最优平均等待时间
  + 考虑一组进程的spn执行
    Average response time = (r1 + r2 + r3 + r4 + r5 + r6)/6
+ 可能导致饥饿
  + 连续的短任务流会使长任务饥饿
  + 短任务可用时的任何长任务的CPU时间都会增加平均等待时间
+ 需要预知未来
  + 怎么预估下一个CPU突发的持续时间
  + 简单的解决办法：询问用户
  + 如果用户欺骗就杀死进程
  + 如果用户不知道怎么办

预估执行时间Tn+1 = αtn + (1 - α)Tn  for 0<=α<=1

T是估计值，t是实际运行时间

Tn+1 = αtn + (1 - α)αtn-1 + (1 - α)(1 - α)αtn-2 + ...

---

#### 最高响应比优先HRRN

+ 在SPN调度的基础上改进
+ 不可抢占（目前该算法不考虑抢占）
+ 关注进程等待了多长时间
+ 防止无限期推迟（有效缓解饥饿）
+ R = (w + s)/s
  + w：waiting time 等待时间
  + s：service time 执行时间
  + 选择R值最高的进程

---

#### 轮循Round Robin, RR

+ 在叫做==量子（或时间切片）==的离散单元中分配处理器
+ 时间片结束时，切换到下一个准备好的进程
  + Processes execute every (n-1)q time units

+ RR花销：额外的上下文切换
+ 时间量子太大
  + 等待时间过长
  + 极限情况退化成FCFS
+ 时间量子太小
  + 反应迅速
  + 但是，吞吐量由于大量的上下文切换开销受到影响
+ 目标
  + 选择一个合适的时间量子  早期Unix或Linux0.01s到现在Linux0.001s
  + ==经验规则：维持上下文切换开销处于1%以内==

---

#### 多级队列

+ 就绪队列被划分成独立的队列
  + e.g. 前台（交互），后台（批处理）
+ 每个队列拥有自己的调度策略
  + e.g. 前台-RR，后台-FCFS
+ 调度必须在队列间进行
  + 固定优先级
    + 先处理前台，然后处理后台
    + 可能导致饥饿
  + 时间切片
    + 每个队列都得到一个稳定的能够调度其进程的CPU总时间
    + e.g. 80%给使用RR的前台，20%给使用FCFS的后台

#### 多级反馈队列

+ 一个进程可以在不同的队列中移动
+ 例如：n级优先级——优先级调度在所有级别中，RR在每个级别中
  + 时间量子大小随优先级级别增加而增加
  + 如果任务在当前的时间量子中没有完成，则降到下一个优先级
+ 优点
  + CPU密集型任务的优先级下降很快
  + I/O密集型任务停留在高优先级

---

#### 公平共享调度FSS

+ FSS控制用户对系统资源的访问
  + 一些用户组比其他用户组更重要
  + 保证不重要的组无法垄断资源
  + 未使用的资源按照每个组所分配的资源的比例来分配
  + 没有达到资源使用率目标的组获得更高的优先级

---

#### 如何评价调度算法

+ 确定性建模
  + 确定一个工作量，然后计算每个算法的表现
+ 队列模型
  + 用来处理随机工作负载的数学方法
+ 实现/模拟
  + 建立一个允许算法运行实际数据的系统
  + 最灵活/具有一般性

---

#### 总结，==实际OS调度算法要复杂的多==

+ FCFS先来先服务
  + 不公平，平均等待时间较差
+ SPN/SRT短进程优先
  + 不公平，但是平均等待时间最小
  + 需要精确预测计算时间
  + 可能导致饥饿
+ HRRN最高响应比优先
  + 基于SPN调度改进
  + 不可抢占
+ Round Robin 轮循
  + 公平，但是平均等待时间较差
+ MLFQ多级反馈队列
  + 和SPN类似
+ Fair-share scheduling公平共享调度
  + 公平是第一要素

---

## 8.5实时调度

Real time

面向的系统不一样，面对实时系统，工业控制，火车，机床，嵌入式等工厂控制环境

+ 定义
  + 正确性依赖于其==时间==和==功能==两方面的一种操作系统
+ 性能指标
  + ==时间约束的及时性（deadlines）==
  + 速度和平均性能相对不重要
+ 主要特性
  + 时间约束的可预测性
  + 确定性
+ 强实时系统
  + 需要在保证的时间内完成重要的任务，必须完成
+ 弱实时系统
  + 要求重要的进程的优先级更高，尽量完成，并非必须
+ 任务（工作单元）job
  + 一次计算，一次文件读取，一次信息传递等等
+ 属性
  + 取得进展所需要的资源
  + 定时参数

|                      ||||||||||||                         |

Released——Execution time——Absolute deadline

|——————Realtive deadline—————|

+ 任务：一系列相似的任务
  + ==周期任务==
    + 任务有规律地重复
    + 周期p = inter-release time (0<p)
    + 执行时间e = 最大执行时间 (0<e<p)
    + 使用率U = e/p
  + 硬时限
    + 如果错过了最后期限，可能会发生灾难性或非常严重的后果
    + 必须验证：在最坏的情况下也能够满足时限吗？
    + ==保证确定性==
  + 软时限
    + 理想情况下，时限应该被最大满足。如果有时限没有被满足，那么就相应地降低要求
    + 尽最大努力去保证
+ 表示一个实时系统是否能够满足deadline要求
  + 决定实时任务执行的顺序
  + 静态优先级调度，在任务执行之前确定优先级
  + 动态优先级调度，任务优先级动态变化
+ RM（Rate Monotonic）速率单调调度
  + 最佳静态优先级调度
  + 通过==周期==安排优先级
  + 周期越短优先级越高
  + 执行周期最短的任务
+ EDF（Earliest Deadline First）最早期限调度
  + 最佳的动态优先级调度
  + Deadline越早优先级越高
  + 执行Deadline最早的任务

---

## 8.6多处理器调度与优先级反转

#### 多处理器调度

+ 两个问题
  + 选择哪一个CPU
  + CPU间的负载均衡

---

+ 多处理器的CPU调度更加复杂
  + 多个相同的单处理器组成一个多处理器
  + 优点：负载共享
+ 对称多处理器SMP
  + 每个处理器运行自己的调度程序
  + 需要在调度程序中同步

---

#### 优先级反转

+ 可以发生在任何基于优先级的可抢占的调度机制中
+ 当系统内的环境强制使高优先级任务等待低优先级任务时发生
+ 火星探路者
  + 优先级反转的持续时间取决于其他不相关任务的不可预测的行为
  + 低优先级任务继承高优先级任务的优先级依赖于它们的共享的资源

+ 优先级天花板：“资源”的优先级和“所有可以锁定该资源的任务中优先级最高的那个任务”的优先级相同
+ 除非优先级高于系统中所有被锁定的资源的优先级上限，否则任务尝试执行临界区的时候会被阻塞
+ 持有最高优先级上限信号量锁的任务，会继承被该锁所阻塞的任务的优先级