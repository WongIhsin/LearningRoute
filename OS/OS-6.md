# 网易公开课——清华大学公开课：操作系统

---

## 同步和互斥

+ 背景
+ 一些概念
+ 临界区（Critical section）
+ 方法1：禁用硬件中断
+ 方法2：基于软件的解决方法
+ 方法3：更高级的抽象

---

## 9.1背景知识

+ 到目前为止
  + 多道程序设计multi-programming：现代操作系统的重要特性
  + 并行很有用（为什么？）
    + 提示：多个并发实体：CPU(s)，I/O，...，用户，...
  + 进程/线程：操作系统抽象出来用于支持多道程序设计
  + CPU调度：实现多道程序设计的机制
  + 调度算法——不同的策略

+ 本周和下周
  + 协同多道程序设计和并发问题

---

+ 独立的线程
  + 不和其他线程共享资源或状态
  + ==确定性====>输入状态决定结果
  + ==可重现====>能够重现起始条件，I/O
  + 调度顺序不重要
+ 合作线程
  + 在多个线程中共享状态
  + 不确定性
  + 不可重现
+ 不确定性和不可重现意味着bug可能是间歇性发生的

---

#### 为什么线程/进程要合作

+ 进程/线程，计算机/设备需要合作
+ 优点1：==共享资源==
  + 一台电脑，多个用户
  + 一个银行存款余额，多台ATM机
  + 嵌入式系统（机器人控制：手臂和手的协调）
+ 优点2：==加速==
  + I/O操作和计算可以重叠
  + 多处理器——将程序分成多个部分并行执行
+ 优点3：==模块化==
  + 将大程序分解成小程序
    + 以编译为例，gcc会调用cpp，cc1，cc2，as，ld
  + 使系统易于扩展

---

#### 合作的例子

+ 程序可以调用函数fork()来创建一个新的进程
  + 操作系统需要分配一个新的并且唯一的进程ID
  + 因此在内核中，这个系统调用会运行
    + new_pid = next_pid++; （next_pid是共享的全局变量）
  + 翻译成机器指令
    + LOAD next_pid Reg1
    + STORE Reg1 new_pid
    + INC Reg1  （加一操作）
    + STORE Reg1 next_pid
+ 假设两个进程并发执行
  + 如果next_pid等于100，那么其中一个进程得到的ID应该是100，另一个进程的ID应该是101，next_pid应该增加到102

---

+ 无论多个线程的指令序列怎样交替执行，程序都必须正常工作
  + 多线程程序具有不确定性和不可重现的特点
  + 不经过专门设计，==调试难度很高==
+ 不确定性要求并行程序的正确性
  + 先思考清楚问题，把程序的行为设计清楚
  + 切忌急于着手编写代码，碰到问题再调试

---

## 9.2一些概念part1

#### Race Condition（竞态条件）

+ 系统缺陷：结果依赖于并发执行或者事件的顺序/时间
  + 不确定性
  + 不可重现
+ 怎样避免竞态
  + 让指令不被打断

---

#### Atomic Operation（原子操作）

+ 原子操作是指一次不存在任何中断或者失败的执行
  + 该执行成功结束
  + 或者根本没有执行
  + 并且不应该发现任何部分执行的状态
+ 实际上操作往往不是原子的
  + 有些看上去是原子操作，实际上不是
  + 连x++这样的简单语句，实际上是由3条指令构成的
  + 有时候甚至连单条机器指令都不是原子的
    + pipeline，super-scalar，out-of-order，page fault

---

+ A和B两个线程互相竞争

  + 其中一个尝试使一个共享的计数器加1

  + 另外一个尝试使一个共享的计数器减1

  + ```c
    i = 0;
    while (i<10)
        i = i + 1;
    printf("A wins!");
    //////////////共享全局变量i////////////////
    i = 0;
    while (i>-10)
        i = i - 1;
    printf("A wins!");
    ```

    

  + 假设内存读取和存储是原子的，但是加1和减1操作不是原子的

+ 无法保证

---

#### Critical section（临界区）

临界区是指进程中的一段需要访问共享资源并且当另一个进程处于相应代码区域时便不会被执行的代码区域

#### Mutual exclusion（互斥）

当一个进程处于临界区并访问共享资源时，没有其他进程会处于临界区并且访问任何相同的共享资源

#### Dead lock（死锁）

两个或以上的进程，在相互等待完成特定任务，而最终没法将自身任务进行下去

#### Starvation（饥饿）

一个可执行的进程，被调度器持续忽略，以至于虽然处于可执行状态却不被执行

---

## 9.3一些概念part2

+ 操作系统中的问题和现实生活中的问题的类比
  + 更好地帮助你理解现实生活的问题
  + 但是，计算机比人更蠢

+ 什么是“面包太多”问题的正确性质
  + 最多有一个人去买面包
  + 如果需要，有人会去买面包

+ 例如，在冰箱上设置一个锁和钥匙（lock和key）
  + 去买面包之前锁住冰箱并且拿走钥匙
  + 修复了“太多”的问题：要是有人想要果汁怎么办
  + 可以改变“锁lock”的含义
  + “锁lock”包含“等待waiting”

---

+ ==Lock锁==：在门、抽屉等物体上加上保护性装置，使得外人无法访问物体内的==东西==，只能等待解锁后才能访问
+ ==Unlock解锁==：打开保护性装置，使得可以访问之前被锁保护的物体类的东西
+ ==Deadlock死锁==：A拿到锁1，B拿到锁2，A想继续拿到锁2后再继续执行，B想继续拿到锁1后再继续执行，导致A和B谁也无法继续执行

---

+ 使用==便签==来避免购买太多面包
  + 购买之前留下一张便签（一种“锁lock”）
  + 买完后移除该便签（一种“解锁unlock”）
  + 如果存在便签就不要购买面包（在便签被移除之前一直等待）
+ 结果
  + 偶尔情况下还是会购买太多面包
  + 线程可以得到检查面包和便签之后，设置便签之前切换的上下文
+ 该解决方案由于会间歇性地失败，使得问题更糟了
  + 使问题更加难以调试
  + 必须做调度器所做的事情

+ 清楚地表明便签无法完全阻塞
+ ==快速修复：将留便签放在第一位==

+ 不会有人买面包

---

## 9.4一些概念part3

+ ==为便签增加标签==怎么样

  + 现在可以在检查之前留便签

+ ```c
  //Thread A
  leave note_1;
  if (no note_2) {
      if (no bread) {
          buy bread;
      }
  }
  remove note_1;
  //Thread B
  leave note_2;
  if (no note_1) {
      if (no bread) {
          buy bread;
      }
  }
  remove note_2;
  ```

+ 可能导致没有线程去买面包

  + 错误时间的上下文切换可能会导致每个线程都认为另外一个线程会去买面包

+ 最难处理的

  + 极其不可能发生的事情也会发生在糟糕的时间
  + 就像UNIX中的一些事情

+ ==这种锁定状态叫做“饥饿（starvation）”？？？==

---

更加复杂的两种便签方案

一个while一个if

```c
//Thread A
leave note_1;
while (note_2) {    //如果没有note_2，那么A可以去买面包
    do nothing;     //否则等待B离开
}
if (no bread) {
    buy bread;
}
remove note_1;

//Thread B
leave note_2;    //如果没有便签1，那么B可以去买面包，否则B离开并且再试一次
if (no note_1) {
    if (no bread) {
        buy bread;
    }
}
remove note_2;
```

+ 有效，但真的不够好，A的执行概率比B大
+ 复杂，难以说服自己它真的有效
+ A和B的代码不同
  + 每个线程的代码也会略有不同
  + 如果线程过多怎么办
+ 当A在等待的时候，其实是在消耗CPU的时间
  + 这种情况叫做“忙等待busy-waiting”

---

+ 解决方案3为每个线程保护了一段“临界区critical section”代码
  + Critical section临界区
    + 临界区是指进程中的一段需要访问共享资源并且当另一个进程处于相应代码区域时便不会被执行的代码区域
  + Mutual exclusion互斥
    + 当一个进程处于临界区并访问共享资源时，没有其他进程会处于临界区并且访问任何相同的共享资源

+ 假设我们有一些锁的实现

  + Lock.Acquire()——在锁被释放前一直等待，然后获得锁
  + Lock.Release()——解锁并唤醒任何等待中的进程
  + 这些一定是原子操作——如果两个线程都在等待同一个锁，并且同时发现锁被释放了，那么只有一个能够获得锁

+ 这样面包问题就很好解决了

  ```c
  breadlock.Acquire(); //进入临界区
  if (nobread) {
      buy bread;
  }
  breadlock.Release(); //退出临界区
  ```

---

## 9.5临界区

+ 互斥：同一时间临界区中最多存在一个线程
+ Progress：如果一个线程想要进入临界区，那么它最终会成功
+ 有限等待：如果一个线程i处于入口处，那么在i的请求被接受之前，其他线程进入临界区的时间是有限制的
+ 无忙等待（可选）：如果一个进程在等待进入临界区，那么在它可以进入之前会被挂起

---

+ 进入和离开临界区的代码
  + ENTER_CRITICAL_SECTION
  + EXIT_CRITICAL_SECTION

+ 基本的机制
  + 禁用中断
  + 软件方法（例如，Peterson算法）
  + 更高级的抽象
+ 比较不同的机制
  + 性能：并发级别

---

## 9.6方法1：禁用硬件中断

+ 时钟中断，使得当前进程可以被打断，OS强制打断进程的能力
+ 没有中断，没有上下文切换，因此没有并发
  + 硬件将中断处理延迟到中断被启用之后
  + 大多数现代计算机体系结构都提供指令来完成
+ 进入临界区
  + 禁用中断
+ 离开临界区
  + 开启中断

---

+ 一旦中断被禁用，线程就无法被停止
  + 整个系统都会为你停下来
  + 可能导致其他线程处于饥饿状态
+ 要是临界区可以任意长怎么办
  + 无法限制响应中断所需的时间（可能存在硬件影响）
+ 仅针对临界区很小的情况是有效的
+ 要小心使用
+ 多CPU下无法解决互斥问题

---

## 9.7方法2：基于软件的解决方案

应用在OS和分布式系统中的软件方案解决互斥问题

---

两个线程，T0和T1

Ti的通常结构

```c
do {
    enter section 进入区域
        critical section 临界区
    exit section 离开区域
        reminder section 提醒区域
} while (1);
```

线程可能共享一些共有的变量来同步它们的行为

+ 共享变量——初始化

  + int turn = 0;

+ turn == i    //表示该谁进入临界区

+ Thread Ti

  + ```c
    do {
        while (turn != i);
        critical section
        turn = j;
        reminder section
    } while (1);
    ```

  + 满足互斥，但是有时不满足progress

    + Ti做其他的事情，Tj想要继续运行，但是必须等待Ti处理临界区

---

+ 共享变量——初始化

  + int flag[2]; flag[0] = flag[1] = 0;

+ flag[i] == 1    //指示进程是否准备好进入临界区

+ Thread Ti

  + ```c
    do {
        while (flag[j] == 1);  //等待j变为0
            flag[i] = 1;
        critical section
        flag[i] = 0;
        reminder section
    } while (1);
    ```

  + ==没有互斥==

---

+ 共享变量——初始化

  + int flag[2]; flag[0] = flag[1] = 0;

+ flag[i] == 1    //Ti想要进入临界区

+ Thread Ti

  + ```c
    do {
        flag[i] = 1;
        while (flag[j] == 1);
        critical section
        flag[i] = 0;
        reminder section
    } while (1);
    ```

  + 满足互斥，但是存在死锁

---

#### 1981年Peterson算法

+ 满足进程Pi和Pj之间互斥的经典的基于软件的解决方法

+ Use two shared data items

+ 使用两个共享数据项

  + int turn;    //指示该谁进入临界区
  + boolean flag[];    //指示进程是否准备好进入临界区

+ Code for ENTER_CRITICAL_SECTION

  + ```c
    flag[i] = TRUE;
    turn = j;
    while (flag[j] && turn == j);
    ```

+ Code for EXIT_CRITICAL_SECTION

  + ```c
    flag[i] = FALSE;
    ```

---

#### 进程Pi的算法

```c
do {
    flag[i] = TRUE;
    turn = j;
    while (flag[j] && turn == j);
        CRITICAL SECTION
    flag[i] = FALSE;
        REMAINDER SECTION
} while (TRUE);
```

#### 另一个稍复杂的算法

进程Pi的算法

```c
flag[0] := false flag[1] := false turn := 0 // or 1
    do {
        flag[i] = TRUE;
        while flag[j] == true {
            if turn ≠ i {
                flag[i] := false
                while turn ≠ i {}
                flag[i] := TRUE
            }
        }
        CRITICAL SECTION
        turn := j
        flag[i] = FALSE;
        EMAINDER SECTION
    } while (TRUE);
```

---

#### 扩展到n个进程的算法：Eisenberg and McGuire's Algorithm

#### 另一个n进程算法：Bakery算法

N个进程的临界区

+ 进入临界区之前，进程==接收一个数字==
+ 得到的数字==最小==的进入临界区
+ 如果进程Pi和Pj收到==相同==的数字，那么如果i<j，Pi先进入临界区，否则Pj先进入临界区
+ 编号方案总是按照枚举的增加顺序生成数字

---

+ Dekker算法（1965）：第一个针对双线程例子的正确解决方案
+ Bakery算法（Lamport 1979）：针对n线程的临界区问题解决方案
+ 复杂
  + 需要两个进程间的共享数据项
+ 需要忙等待
  + 浪费CPU时间
+ 没有硬件保证的情况下无真正的软件解决方案
  + Peterson算法需要原子的LOAD和STORE指令

---

## 9.8方法3：更高级的抽象

+ 硬件提供了一些原语
  + 像中断禁用，原子操作指令等
  + 大多数现代体系结构都这样
+ 操作系统提供更高级的编程抽象来简化并行编程
  + 例如：锁，信号量
  + 从硬件原语中构建

---

+ 锁是一个抽象的数据结构

  + 一个二进制状态（锁定/解锁），两种方法
  + Lock::Acquire()——锁被释放前一直等待，然后得到锁
  + Lock::Release()——释放锁，唤醒任何等待的进程

+ 使用锁来编写临界区

  + 前面的例子变得简单起来：

  + ```c
    lock_next_pid->Acquire();
    new_pid = next_pid++;
    lock_next_pid->Release();
    ```

---

+ 大多数现代体系结构都提供特殊的原子操作指令
  + 通过==特殊的内存访问电路==
  + 针对单处理器和多处理器
+ Test-and-Set测试和置位（是一条机器指令）
  + 从内存中读取值
  + 测试该值是否为1（然后返回真或假）
  + 内存值设置为1
+ 交换
  + 交换内存中的两个值

---

Test-and-Set和交换只要提供一条，就可以实现进入和离开临界区的操作

---

```c
boolean TestAndSet (boolean *target)
{
    boolean rv = *target;
    *target = TRUE;
    return rv:
}

void Exchange (boolean *a, boolean *b)
{
    boolean temp = *a;
    *a = *b;
    *b = temp;
}
```

上面两个有特殊的电路构成，是一条机器指令，不会被中断打断

```c
class Lock {
    int value = 0;
}
```

```c
Lock::Acquire() {
    while (test-and-set(value))
        ; //spin
    //忙等待
}
```

+ 如果锁被释放，那么test-and-set读取0并将值设置为1
  锁被设置为忙并且需要等待完成
+ 如果锁处于忙状态，那么test-and-set读取1并将值设置为1
  不该变锁的状态并且需要循环（自旋spin）（忙等待）

```c
Lock::Release() {
    value = 0;
}
```

可以很简单地支持n个进程

但是

+ ==使用忙等待的锁==
  + 就像上面使用test-and-set实现的锁一样
  + 线程在等待的时候消耗CPU周期

#### 无忙等待：唤醒操作

```c
class Lock {
    int value = 0;
    WaitQueue q;
}

Lock::Acquire() {
    while (test-and-set(value)) {
        add this TCB to wait queue q;
        schedule();
    }
}

Lock::Release() {
    value = 0;
    remove one thread t from q;
    wakeup(t);
}
```

如果临界区短，可以使用忙等待

如果临界区开销大，使用睡眠

---

#### 交换

+ 共享数据（初始化为0）

  + int lock = 0;    // 0表示还没有线程要进入临界区

+ 线程Ti

  + ```c
    int key;
    do {
        key = 1;
        while (key == 1) exchange(lock, key);
            critical section
        lock = 0;
            remainder section
    }
    ```

---

+ 采用原子机器指令的优点
  + 适用于单处理器或者共享主存的==多处理器==中==任意数量的进程==
  + 简单并且容易证明
  + 可以用于支持多临界区

+ 采用原子机器指令现在广泛使用
+ 缺点
  + 忙等待消耗处理器时间
  + 当进程离开临界区并且多个进程在等待的时候可能导致饥饿
  + ==死锁==
    + 如果一个低优先级的进程拥有临界区并且一个高优先级进程也需求，那么高优先级进程会获得处理器并等待临界区

---

+ 锁是更高等级的编程抽象
  + 互斥可以使用锁来实现
  + 通常需要一定等级的硬件支持
+ 常用的三种实现方法
  + 禁用中断（仅限于单处理器）
  + 软件方法（复杂）
  + 原子操作指令（单处理器或多处理器均可）
+ 可选的实现内容
  + 有忙等待
  + 无忙等待







