# 计算机系统要素：从零开始构建现代计算机

What's in a name? That which we call a rose by any other name would smell as sweet 

---

# 第六章：汇编编译器Assembler

机器语言的两种表现形式，即**汇编形式**和**二进制形式**。本章介绍如何系统地将汇编语言编写的程序翻译成二进制形式。以及阐述如何开发Hack汇编器

因为符号化汇编命令symbolic assembly commands与其对应的二进制代码之间的关系是很简单的，所以编写汇编编译器（使用某种高级语言编写）并非是很难的任务。唯一的复杂性在于：**允许汇编程序使用符号来指代内存地址**。希望编译器来管理这些用户自定义的符号，将它们解析成物理内存地址。一般可以使用**符号表symbol table**来完成这个任务，这种符号表是经典的数据结构，应用在很多软件编译过程中

---

机器语言一般分为两种：**符号型symbolic**和**二进制型binary**

二进制码（比如1100 0010 1000 0001 1000 0000 0000 0111）代表一条实际的机器指令，它能被底层硬件所理解。指令最左边的8位代表操作码（比如LOAD），接着的8位代表寄存器（比如R3），剩下的16位表示地址（比如7）。根据硬件的逻辑设计和相应的机器语言，整个32-位指令可以让硬件去执行操作“将Memory[7]的内容加载到寄存器R3中”

现代计算机平台支持数十个（即使不是成百上千个）这样的基本操作。如此一来，机器语言会变得相当复杂，因为其涉及到很多操作码、不同的内存寻址模式和不同的指令格式

解决此复杂性的方法之一是，使用约定的语法来表示机器指令，例如用LOAD R3, 7而不是1100 0010 1000....0111表示机器语言。由于将符号表示翻译成二进制码是直截了当的，所以允许用符号表示法来编写底层程序，并用计算机程序将底层程序翻译成二进制码是很有意义的

#### 符号化的语言称为汇编Assembly，翻译程序称为汇编编译器Assembler

汇编编译器对每个汇编命令的所有部分进行解析，将每个部分翻译成它对应的二进制码，并将生成的二进制码汇编成真正能被硬件执行的二进制指令

---

#### 符号Symbols

二进制指令用二进制码表示，根据定义，它们使用实际的数字来指代内存地址，比如，假设某个程序用变量weight来表示不同事物的重量，假设该变量已经被映射到计算机内存地址为7的内存单元内。在二进制码层级上，操作weight变量的指令必须使用明确的地址7来指代它。然而，一旦进入汇编级，我们就可以允许编写命令LOAD R3, weight来取代LOAD R3, 7。两种情况都会执行相同的操作，将R3设为Memory[7]的内容

符号在汇编程序通常有两个用途

+ **变量Variables**：程序员可以使用符号的变量名称，翻译器会“自动地”为其分配内存地址。需要注意的是，这些地址的实际值是没有意义的，只要在程序的整个编译过程中，每个符号始终被指代为同一地址就可以了
+ **标签Labels**：程序员可以在程序中用符号来标注不同的位置，比如，可用标签loop来指代特定代码段的起始地址，程序中的其他命令就可以有条件或无条件地执行goto loop指令

---

在汇编语言中引入符号意味着，汇编编译器必须必简陋的文本处理程序更强大，好在将约定的符号翻译成约定的二进制码并不太复杂，同时，用户定义的变量名称和符号标签symbolic labels与实际内存地址的映射则不是那么简单。事实上，这个确定符号地址的任务是从硬件层级上升到软件层级过程中遇到的第一个挑战

---

# 符号解析Symbol Resolution

首先来指定两个任意性规则：其一，翻译后的代码将被存储到计算机中起始地址为0的内存中；其二，变量将会被分配到起始地址为1024的内存中（这些规则依赖于特定的目标硬件平台）

接下来构建一个**符号表symbolic table**，在源代码中，每遇到一个新符号xxx，我们就在符号表中添加一行（xxx, n）。根据规则约定，n是分配给对应符号的内存地址，在符号表建立完成之后，我们利用它来将程序翻译成无符号的版本

+ 首先，要注意到我们定义的变量分配规则决定了能运行的程序最多只能有1024条指令，然后实际的程序（比如操作系统）显然要大很多，因此存储变量的基地址也应该设得距离代码存储区更远一些
+ 其次，“每条源代码命令映射到一个字word”的假设恐过于天真，一般来说，某些汇编命令，比如if i=101 goto end会被翻译成好几条机器指令，因此它会占据好几个内存单元。为了解决此问题，翻译程序会记录每条源代码产生的字的个数，然后相应地更新它的“指令内存计数器Instruction memory counter”
+ 最后，对于“每个变量用一个单独的内存单元来表示”的假设可能也不切实际，编程语言支持多种类型的变量，它们在目标计算机上占用不同的内存空间。比如C语言数据类型short和double分别代表16-位和64-位数字。当C程序在16-位机器上运行时，short变量将占用1个单独的内存单元，long变量将占用4个连续单元组成的块，因此，当为变量分配内存空间时，翻译程序必须考虑它们的数据类型和硬件内存单元的宽度

---

#### 汇编编译器Assembler

汇编程序在被计算机执行之前，必须被翻译成计算机的二进制机器语言。翻译任务是由称为汇编编译器的程序来完成。汇编编译器的输入是一串汇编命令，然后产生一串等价的二进制指令作为输出。生成的代码被加载到计算机的内存中然后被硬件执行

可见，汇编编译器实际上主要是个文本处理程序，设计目的是用来提供翻译服务。编写汇编编译器的程序员必须有完整的汇编语法说明文档和相应的二进制代码。有了这样的约定（通常称为机器语言规范），就不难编写程序，让其对每个符号命令执行下面的任务

+ 解析出符号命令内在的域
+ 对于每个域，产生机器语言中相应的位域
+ 用内存单元的数字地址来替换所有的符号引用
+ 将二进制码汇编成完整的机器指令

其中三个任务（解析、代码生产和汇编）是相当容易实现的，而**符号处理**则相对较为复杂，是汇编编译器的主要功能

---

#### Hack汇编到二进制的翻译规范详述Hack Assembly-to-binary Translation Specification

#### 语法规约和文件格式Syntax Conventions and File Formats

#### 二进制代码.hack文件

二进制代码文件由文本行组成，每一行由16个0/1组成的ASCII码构成一个序列，该序列对一个单一的16-为机器语言指令进行编码。因此，文件中的所有行在整体上代表一个机器语言程序。当机器语言程序被加载进计算机的指令内存中时，文件的第n行二进制码被存储到地址为n的指令内存单元内（设程序命令行的计数和指令内存的起始地址都是从0开始）

#### 汇编语言.asm文件

汇编语言文件由文本行组成，每一行代表一条**指令instruction**或者一个**符号声明symbol declaration**

+ 指令Instruction：A-指令或C-指令
+ Symbol：该伪命令将Symbol绑定到该程序中下一条命令的地址上。因为他并不产生机器代码，所以称之为“**伪命令pseudo-command**”

**常数Constants**和**符号Symbols**：常数必须是非负的，用十进制表示
注释
空格
大小写习惯：汇编助记符必须大写，剩余部分区分大小写，标签大写，变量名称小写

#### 指令Instructions

Hack机器语言包含两种指令类型，分别是**寻址指令A-指令Addressing Instruction**和**计算指令C-指令Compute Instruction**

#### 符号Symbols

Hack汇编命令通过使用常数或符号来指代内存单元（地址）。汇编程序中的符号来源于三个方面

+ **预定义符号Predefined Symbols**：注意到Hack的RAM地址0到5可以使用两个预定义符号来指代，比如R2和ARG都指代RAM[2]
+ **标签符号Label Symbols**：伪命令{Xxx}定义符号Xxx来指代存有程序中下一条命令在指令内存中的地址，每个标签只能被定义一次，可以在程序中的任何地方使用，甚至可以在它自身被定义的那一行之前使用。
  （先建立符号表，个人理解，即使在自身被定义之前使用了，由于先建立的符号表，实际上使用的时候还是知道是哪一行）
+ **变量符号Variable Symbols**：任何出现在汇编程序中的符号Xxx，如果它不是预定义符号也没有在其他地方使用Xxx命令，那么他就被当作是变量，每当程序遇到一个新的变量时，就把它连续地映射到从16开始的内存中去

将每个独立的汇编命令翻译成其等价的二进制指令是直接并一一对应的过程。每个命令被单独地翻译。特别是，汇编命令中的每个域会被翻译成对应的编码，命令中的每个符号也会被解析成相应的数字地址

---

我们这里提出一个基于4个模块的汇编编译器的实现：**语法分析器Parser**模块用来对输入文件进行语法分析；**编码Code**模块用来提供所有汇编命令所对应的二进制代码；**符号表Symbol Table**模块用来处理符号。另外还有一个主程序用来驱动整个编译过程

---

#### Parser模块The Parser Module

语法分析器parser的主要功能是，将汇编命令分解为其所表达的内在含意(域和符号)

Parser封装对输入代码的访问操作，功能包括：读取汇编语言命令并对其进行解析：提供“方便访问汇编命令成分（域和符号）”的方案：去掉所有空格和注释

#### Code模块The Code Module

将Hack汇编语言助记符翻译成二进制码

#### 无符号程序的汇编编译器Assembler for Programs with No Symbols

#### SymbolTable模块The SymbolTable Module

因为Hack指令可能包含符号，作为翻译过程的一部分，必须为这些符号确定实际的地址。汇编编译器使用**符号表symbol table**来完成这个任务，符号表用来建立和维持符号与其地址之间的关联。**哈希表hash table**就是表示这种关系的经典数据结构之一。在大多数编程语言中，这样的数据结构都是作为标准库的一部分二存在的，因此没有必要从头来开发它

SymbolTable：在符号标签symbolic labels和数字地址之间建立关联

#### 有符号程序的汇编编译器Assembler for Programs with Symbols

汇编程序允许在符号被定义之前使用符号标签（即goto命令的目的地），此功能为汇编程序员带来了极大的便利，却使得汇编编译器开发者的工作变得更复杂

# 解决这个问题的方法之一是：编写“两遍two-pass”，从头至尾地读取两次代码

#### 第一遍读取时，汇编编译器构建符号表但并不产生代码。第二遍读取时，程序中遇到的所有标签符号所对应的内存地址都已经记录在符号表中了，这个符号表就是在编译器在第一次读取程序的过程中建立的，因此，汇编编译器能用每个符号相关的含义（数字地址）来替换该符号，并产生最后的二进制码

#### 初始化

用所有**预定义符号**和它们预分配的RAM地址对符号表进行初始化

#### 第一遍读取阶段

该阶段主要是在符号表中建立每条命令及其对应的地址。逐行处理整个汇编程序，构建符号表而不生成任何代码。处理程序的每一行时，利用数字来记录ROM地址——当前命令最终将被加载到这个地址中。这个数字从0开始，不管碰到C-指令还是A-指令都自动加1，但是当遇到标签伪指令或注释时不发生变化。每次遇到一条伪指令（Xxx）时，在符号表上加一个新条目来将Xxx与最终用于存储程序中下一条指令的ROM地址关联起来。在这个阶段程序中所有标记和它们的ROM地址被加入到符号表中。程序的变量放在第二阶段处理

#### 第二遍读取阶段

现在重新对整个程序进行处理，对每一行进行语法分析，每次遇到符号化A-指令时，即@Xxx指令中Xxx是符号而不是数字时，就在符号表中查找Xxx。如果在符号表中找到了该符号，就用其对应的地址来替换该符号以完成命令的翻译。如果在符号表中没有找到该符号，那么它必定代表变量。为了处理这个变量，就在符号表中添加(Xxx, n)，这里n代表下一个可使用的RAM地址。分配的RAM地址是连续数字，从地址16开始（紧接着预定义符号的地址之后）

这样，汇编编译器的实现过程就完成了

---

大多数汇编编译器会具有Hack所缺乏的**更好的符号处理能力**，比如，这些汇编编译器可以允许程序员将符号与特定的数据地址联系起来对符号执行“常数运算”（比如，使用table+5来指代从table所代表的起始地址的第5个内存位置）等等

### 宏命令macro commands

此外，很多汇编编译器能够处理**宏命令macro commands**。宏命令是简单的机器指令序列，比如，Hack汇编编译器可以扩展到能将约定的宏命令，D=M[xxx]，翻译成两个指令：@xxx和D=M，显然，这样的宏命令能够在相当程度上，以较低的翻译代价来简化涉及常用操作的程序编写

#### 需要注意到

**单独stand-alone**的汇编编译器很少在实际中用到，首先，人们很少编写汇编程序，这主要是由编译器来负责。编译器是自动机，它不必为生成符号的命令而费心，因为它可以直接产生二进制机器代码（**个人理解，这里应该是说编译器可以自动实现而不需要人工参与，并非是无需实现**）。另一方面，很多高级语言编译器允许程序员在高级程序中嵌入汇编语言代码部分。这个功能在C语言编译器中相当普遍，它让程序员能直接控制底层硬件以达到优化的目的

