# 计算机系统要素：从零开始构建现代计算机

---

# 第十二章：操作系统Operating System

在整个构建中的最后一个接口就是**操作系统OS**。

### OS的作用就是来衔接计算机的硬件系统和软件系统，以使得整个计算机对程序员和用户而言更容易使用

例如，为了使得文本“Hello World”在计算机屏幕上显示，必须在特定的屏幕位置上画几百个像素，这可以通过参考硬件规范，编写相关的代码来完成，该代码在驻留RAM的屏幕映像中放置必要的比特位。显然，高级程序员希望事情能够变得更好些。他们希望使用诸如printString("Hello World")的命令，然后让别人来负责其中的实现细节。操作系统在其中就起到了很重要的作用。

本书所描述的OS服务包含了最小规模的操作系统，主要是：

+ #### 以一种对软件友好的方式封装了不同的硬件服务；

+ #### 用不同的函数和抽象数据类型扩展了高级语言。

在这个意义上的操作系统与语言的标准程序库的分界线就不是那么明显。事实上，某些现代语言（例如Java）就趋向于将很多经典的操作系统服务（比如GUI管理，内存管理，和多任务处理等）连同很多语言扩展一起打包到其标准程序库中

按照这种模式，本章描述并构建的服务就可以被看作是简单的OS和Jack语言的标准程序库的集合。该OS被打包成一组Jack类，每个类通过Jack子程序调用来提供一组相关的服务。这个OS与工业级强度的操作系统有很多相似的特点，但是它仍然缺少大量的OS特性，比如进程管理、磁盘管理、通信等

---

#### 操作系统通常是由高级语言编写，并被编译成二进制形式，就像任何其他程序一样

Jack的OS也不例外，可以完全由Jack编写而成。然而与其他由高级语言编写的程序不同的是，操作系统代码必须了解它所运行的硬件平台。换句话说，为了对高层的应用程序员隐藏这些硬件细节，OS程序员必须编写能够直接操纵这些细节的代码（这个任务需要参考硬件规范文档）

---

# 背景知识Background

---

## 12.1.1数学操作Mathematical Operations

计算机系统必须支持诸如加法、乘法和除法这样的数学操作。通常，加法在ALU级的硬件中实现。其他操作如乘法和除法，可以根据计算机的性价比要求，通过硬件或软件来处理。这里介绍乘法、除法以及平方根操作是如何在OS级的软件中被有效实现的，**注意：这些数学操作的硬件实现同样也基于这里提到的算法**

### 效率第一

数学算法操作在n-位数上，在典型的计算机体系中，n=16,32或64，通常，期望运行时间与参数n成比例（或者至少是n的多项式）的算法。

#### 运行时间与n-比特位的**数值**成比例的算法是不可接受的，因为这些值是以n为指数的，O(x)即以n为指数

下面介绍的乘法算法的运行时间就不是与被乘数的值成比例，而是与n成比例。因此，对于任意的乘数与被乘数，该算法仅需要c·n个基本操作，这里c是个很小的常数，它代表在每个循环迭代中执行的基本操作的数量

#### 使用标准的“Big-Oh(大O)”表示法，即O(n)，来描述算法的运行时间

可以把O(n)当作“按照n的数量级顺序的一种表示”。有了这个概念，就可以开始介绍一种有效的n-比特位的数的乘法x·y算法，它的运行时间是O(n)，而不是O(x)或O(y)

---

#### 乘法

小学标准乘法，356乘以27，两个数排列起来，一个在另一个之上，接着，用7来乘上356的每个数字，然后，向左移动一个位置，用2来乘上356的每个数字，最后，把每一列的和加起来，于是得到最后的结果

```
multiply(x, y):
  //Where x, y >=0
  sum = 0
  shiftedX = x
  for j = 0 ... (n-1) do
    if (j-th bit of y) = 1 then
      sum = sum + shiftedX
    shiftedX = shiftedX * 2
```

---

#### 除法

计算两个n-比特位的数的除法x/y，为了提高该算法的效率，可以在每次迭代中试着从x上减去y的一个较大的倍数，事实上，这正是学校所教的**长除法(long devision)**x/y方法的基本原理。每次迭代中，试图从x上减去y的最大可能的位移，也就是y·T，这里T是最大的以10为幂的数，并且满足y·T<=x

```
divide(x, y):
  //Integer part of x/y, where x>=0 and y>0
  if y > x return 0
  q = divide(x, 2*y)
  if (x - 2*q*y) < y
    return 2*q
  else
    return 2*q + 1
```

该递归算法的运行时间由递归的深度来决定，因为在每次递归中，y的值被乘上2，且一旦出现y>x立即结束，于是递归深度受到n（x的位数）的限制。每个递归层都包含了一个常数数量的加法，减法和乘法操作，意味着整个运行时间为O(n)个这样的操作

因为每个乘法操作也需要O(n)次加法和减法操作，所以该算法被认为是次优的

如果仔细观察，会发现可以不使用乘法来计算乘积2·q·y，我们可以根据在前一个递归层的该乘积值，使用加法来求出其当前的值

---

#### 平方根

可以采用很多不同的方法来有效地计算平方根，例如**牛顿-拉夫逊方法Newton-Raphson method**、**泰勒级数展开式Taylor series expansion**

我们采用较简单的方法，平方根函数首先是单调递增的，其次我们知道如何计算其反函数x=y^2，综合考虑这两个特点，有理由使用**二叉查找binary search**来计算平方根

要注意的地方是每个循环迭代都进行了一个常数数量的算术操作。因为迭代的数量受到n/2的限制，所以算法的运行时间是O(n)次算术操作

```
sqrt(x):
  //计算y=x^0.5的整数部分。策略：
  //通过在0..2^(n/2)-1范围内执行二叉搜索，来确定一个满足条件
  //y^2<=x<(y+1)^2的y(对于0<=x<=2^n)
  y=0
  for j=n/2-1 .. 0 do
    if (y+2^j)^2 <=x then y=y+2^j
  return y
```

---

## 12.1.2数字的字符串表示String Representation of Numbers

计算机在内部使用二进制码来表示数字。人类习惯于用十进制的表示法来处理数字，因此，当人们要读取或输入数字时，计算机必须要执行二进制到十进制的转换或者十进制到二进制的转换

#### 通常，这些工作是由操作系统提供的底层服务程序来处理

我们关注的是字符的一个子集，即10个表示数字的字符，这10个字符的ASCII码如下所示
字符：		0-9
ASCII码：  48 -57

#### 为了计算给定数字0<=x<=9的ASCII码，只需将x加上48即‘0’的ASCII码即可，同理，ASCII码48<=c<=57所表示的数字值可以通过c-48来获得

```
int2String(n)://递归
  lastDigit = n%10
  c = 代表lastDigit的字符
  if n<10
    return c
  else
    return int2String(n/10).append(c)
```

```
string2Int(s):
  v = 0
  for i=1...s的长度 do
    d = 数字s[i]的整数值
    v = v*10+d
  return v
  //假设s[1]是字符串s的第一个字符
```

---

## 12.1.3内存管理Memory Management

#### 动态内存分配

计算机的程序会声明并使用各种类型的变量，包括如整数、布尔数等简单的数据类型以及如数组、对象等复杂的数据类型。

#### 高级语言的最大优点之一是程序员不必关心内存管理细节：比如为变量分配内存空间；以及当该变量不在使用时，回收为其分配的内存空间

#### 所有关于内存管理的琐碎工作都由编译器、操作系统和虚拟机在后端来完成

不同变量的内存在程序生命周期中的不同时刻被分配，例如

#### 静态变量在编译期间由编译器为其分配内存，而局部变量则在每个子程序开始运行时被分配在堆栈内，其他变量的内存则是在程序的执行过程中被动态分配，这就需要操作系统的帮助了

例如，每当Java程序创建新数组或新对象时，对应的内存块就会被分配，而这块内存块的大小只有在程序运行期间才能确定。当数组或对象不再使用时，其内存空间会被收回。C++中释放不再使用的内存空间是程序员的任务，然而在其他语言如Java中，会自动地产生“垃圾回收”

#### 被用于进行动态内存分配的内存段称为堆heap，负责管理这个资源的就是操作系统

操作系统使用不同的技术来处理动态内存分配和去配。这些技术通常在两个称为alloc()和deAlloc()的函数中实现

#### 基本内存管理算法

该算法所管理的数据结构就是一个单一的指针，称为**free**，它指向还未经过分配的内存的堆基地址

#### 改进的内存分配算法

该算法管理一个由可使用内存段构成的链表，称为**freeList**。每个内存段包含两个字段：该内存段的长度和指向链表中下个内存段的指针。这些字段可被保存在内存段起始的两个内存位置中。例如：`length==segment[0]`和`segment.next==segment[1]`

#### 要分配指定大小的内存块时，该算法必须在freeList中搜索大小合适的内存段

两种常用的启发式算法来完成此搜索任务。最优适应Best-fit算法，最先适应First-fit算法

#### 最优适应(Best-fit)算法：在整个链表中搜索大小最匹配的内存段分配给变量

#### 最先适应(First-fit)算法：将链表中找到的第一个”大小能满足变量要求的内存段“分配给变量

#### 一旦找到合适的段，就从中取出所需要的内存块（==返回块起始位置的前一个位置，block[-1]，被用来保存其长度，在内存空间的去配过程中会用到该长度值==）。接着，该段在freeList中被更新，成为分配之后剩余的部分，如果块中没有剩余的内存，或者若剩余部分太小，则从freeList中去掉整个段

#### 收回无用对象的内存块时，该算法将收回的块==追加==到freeList中

经过频繁分配、收回操作之后，动态分配机制会产生内存碎片，因此，应该考虑一些“**碎片整理**”的操作，即==将那些虽然在物理上连续而在freeList中从逻辑上被划分到不同内存段的内存区域合并起来==。可以在对象被去配时，或alloc()没有找到合适内存块时执行碎片整理操作，也可依据其他条件来执行

---

## 12.1.4变长数组和字符串Variable-length Arrays and Strings

现代语言中的常用方法是使用String类来提供创建并操作字符串对象的服务。在物理上，字符串对象可以通过使用数组来实现，在创建字符串时，==一般为该数组分配的空间足够用来保存可能的最大长度==，而字符串的实际长度可能比最大值要短，且应在字符串对象的整个生命周期中保存该实际长度值。通常，超出当前字符串长度的数组单元不会作为字符串的内容

大多数编程语言都有字符串类型，以及其他变长数据类型。字符串对象通常由语言的标准程序库提供

---

## 12.1.5输入/输出管理Input/Output Management

计算机一般会连接到各种输入/输出设备，各个IO设备都有其自己的机电特性和物理特性，因此在这些设备上进行数据读写操作涉及到很多技术细节。对程序员而言，高级语言利用高级操作指令将这些细节隐藏（封装）起来，实际的IO操作是通过操作系统提供的服务实现的

如此一来，操作系统的重要功能之一就是要处理连接到计算机上的各种IO设备，可以使用一组称为**设备驱动device driver**程序的操作系统服务来处理IO底层操作，封装设备接口的物理细节，达到方便访问和使用设备的目的

#### 图形输出

现今的大多数计算机使用**光栅raster，也称为位图bitmap**显示技术。在位图屏幕中所能执行的唯一基本操作就是绘制一个**像素pixel**

#### 字符输出

#### 键盘处理

---

#### Jack OS规范详述The Jack OS Specification

---

## 观点Perspective