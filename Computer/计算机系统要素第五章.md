# 计算机系统要素：从零开始构建现代计算机

---

# 第五章：计算机体系结构Computer Architecture

---

## 存储程序概念The Stored Program Concept

一个由有限硬件组件构成的计算机却可以执行无限的任务队列，从交互式游戏到字处理到科学计算。这都是“**存储程序stored program**”概念的功劳硕果，这个概念到现在仍然被认为是现代计算机史上最具意义的发明

不同于1930年以前的机械计算机，这些程序的逻辑并没有被嵌入到硬件中，而是被存储到计算机的存储设备memory中，跟数据一样，成为所谓的“**软件software**”。因为计算机的操作是通过正在执行的软件来向用户展示其功能，所以每次向计算机中载入不同的程序时，同样的硬件平台可以实现完全不同的功能

---

## 冯·诺依曼结构The von Neumann Architecture

存储程序概念是很多抽象的、应用型计算机模型的关键，其中最著名的是**通用图灵机**(1936)和**冯·诺依曼机**(1945)

图灵机是描述虚拟的简单计算机的抽象机，主要用来分析计算机系统的逻辑基础；冯·诺依曼机是实际应用型的体系结构，几乎是今天所有计算机平台的基础

冯·诺依曼体系结构的基础是一个**中央处理单元CPU Central Processing Unit**，它与**记忆设备memory device**即内存(一切有存储功能的设备)进行交互，负责从**输入设备input device**接收数据，向**输出设备output device**发送数据

个人理解：现代计算机数据是都必须通过内存来与CPU交互的，但CPU可以直接控制输入输出

#### 这个体系结构的核心是存储程序的概念：计算机内存不仅存储着要进行操作的数据，还存储着指示计算机运行的指令

---

## 内存Memory

冯·诺依曼机的内存中有两种类型的信息：数据项data items和程序指令programming instructions。对这两种信息通常采用不同的方式来处理，在某些计算机中，它们被分别存储到不同的内存区中。

尽管它们具有不同功能，但两种信息都以二进制数形式存储在具有通用结构的随机存储器中（一个连续的固定宽度的单元阵列，也称为字即word，或者存储单元，每个单元都有一个独立的地址）表示。因此，一个独立的字（代表一个数据项或者一条指令）通过它的地址来指定

#### 数据内存Data Memory

高级程序high-level programs操纵抽象的元件artifacts，例如变量variables、数组arrays和对象objects，这些数据抽象被翻译成机器语言后，就变成一连串的二进制数，存储在计算机的**数据内存**中。一旦通过指定的地址，在数据内存中找到对应的内存单元，就可以对该内存单元进行**读操作**或**写操作**

#### 指令内存Instruction Memory

当高级命令被翻译成机器语言时，它变成一系列的二进制字word，这些字代表机器的指令。这些指令被存储在计算机的**指令内存**中。在计算机操作的每一步，CPU从指令中取出一个字，对其进行解码，从而执行指定的指令，然后计算下一条将要执行的指令，因此，改变指令中的内容会完全改变计算机的操作

驻留在指令内存中的指令格式遵守机器语言的规约，在一些计算机中，每个操作的规范及其代表其操作数的代码是用一个单一字长的指令来表示的。其他计算机则将这个规范分为几个单字来表示

---

## 中央处理器Central Processing Unit

CPU是计算机体系的核心，负责执行已被加载到指令内存中的指令。这些指令告诉CPU去执行不同的计算，对内存进行读/写操作，以及根据条件跳转去执行程序中其他指令。CPU通过使用三个主要的硬件要素来执行这些任务：

+ **算术逻辑单元ALU Arithmetic-Logic Unit**：负责执行计算机中所有底层的算术操作和逻辑操作
+ 一组**寄存器Registers**：CPU的设计是为了能够快速地执行简单计算。为了提高它的性能，将这些和运算相关的数据暂存到某个局部存储器中是十分必要的，这远比从内存中搬进搬出要好，因此每个CPU都配有一组**高速寄存器**，每个寄存器都能保存一个单独的字
+ **控制单元Control Unit**：计算机指令用二进制代码来表示，通常具有16、32或64位宽。在指令能够被执行之前，须对其进行解码，指令里面包含的信息向不同的硬件设备（ALU，寄存器，内存）发送信号，指使它们如何执行指令。指令的解码过程是通过某些**控制单元control unit**完成的。这些控制单元还负责决定下一步需要取出和执行哪一条指令

#### CPU操作现在可以被描述成一个重复的循环：从内存中取一条指令(字)；将其解码；执行该指令，取下一条指令；如此反复循环

指令的执行过程可能包含下面的一些子任务：让ALU计算一些值，控制内部寄存器，从存储设备中读取一个字，或向存储设备中写入一个字。在执行这些任务的过程中，CPU也会计算出下一步该读取并执行哪一条指令。

---

## 寄存器Registers

内存访问是很慢的过程，当CPU被指示去取内存中地址j的内容时，下面的一些过程会连续发生

+ j从CPU传到RAM
+ RAM的直接访问逻辑direct-access logic选中地址为j的寄存器
+ RAM[j]的内容传回到CPU

寄存器也能提供同样的数据访问功能，但没有来回的数据传递和寻址开销。

#### 首先，寄存器位于CPU芯片内部，所以对它们的访问几乎可以瞬间完成；其次，与数百万个内存单元相比，寄存器数量非常少，因此，机器语言指令可以使用短短的几个位就能指定要操作的寄存器在什么位置，这样的指令格式也更短

基于不同的目的，不同的CPU采用不同数量、不同类型的寄存器，在一些计算机体系结构中，每个寄存器可以有多种用途

#### 数据寄存器Data Registers

这些寄存器为CPU提供短期记忆memory服务，比如，当计算(a-b)·c时，必须首先计算a-b的值并记住它，虽然这个结果可以暂时地被存储到存储单元中，但更好的办法是存储在CPU内部即数据寄存器中

#### 寻址寄存器Addressing Registers

为了进行读写，CPU必须连续访问内存中的数据，这样我们必须确定被访问的内存字word所在的内存地址。在某些情况下这个地址作为当前指令的一个部分给出，而其他某些情况下它依赖于前面一条指令的执行结果。对于后者，这个地址应该被存储到某个寄存器中，使得该寄存器的内容在今后的操作中能够被当作存储单元的地址，这就需要用到寻址寄存器

#### 程序计数寄存器Program Counter Register

执行程序时，CPU必须总是知道下一条指令在指令内存中的地址，这个地址保存在一个特殊的寄存器即程序计数器中（或称PC，Program Counter）PC的内容就被当作从指令内存中取指令的地址。因此，在执行当前指令的过程中，CPU通过两种方式之一来更新PC的内容：1、如果当前指令不包括goto命令，PC增1以便使指针指向程序中的下一条指令；2、如果当前指令中包含需要执行的goto n命令，则CPU将PC置为n

---

## 输入和输出Input and Output

计算机使用一组输入输出I/O设备来与外部环境进行交互，这些设备包括屏幕、键盘、扫描仪、网络接口卡、光驱等，还有一些复杂的集成在汽车、武器系统、医疗器械等机器中的嵌入式计算机

计算机科学家设计不同的方案将这些不同外设的物理细节封装起来，让计算机能以相同的方式对它们进行操作，其中最简单的实现技巧之一就是**I/O映像memory-mapped I/O**

#### I/O映像基本思想是

创建I/O设备的二进制仿真，使其对于CPU而言，“看上去”就像普通的内存段，特别地，每个I/O设备在内存中都分配了独立的区域，作为它的“内存映像”，对于输入设备（键盘鼠标等），内存映像能连续不断地反映设备的物理状态；对于输出设备（屏幕扬声器等），内存映像连续地驱动设备的物理状态

当外部事件作用于输入设备时，比如键盘上按键或者移动鼠标，某些特定的值就被写入它们各自对应的内存映像中，同样的，想要控制某些输出设备，比如，在屏幕上画图或者播放一首歌，就将一些特定值写入它们各自对应的内存映像

从硬件的角度来看，这个方案需要所有I/O设备提供类似于**记忆单元memory unit，或称内存单元**的那种接口。从软件的角度看，需要对每个I/O设备定义交互协议，这样程序才能正确地访问它。若有大量可用的计算机平台和IO设备，就不能明白各类**标准规范standards**在计算机体系结构设计中所起的重要作用

#### I/O内存映像体系的实际应用是很有意义：

CPU以及整个平台的设计可以完全不依赖于要与计算机进行交互的I/O设备，也不依赖于I/O设备的数量和种类，无论何时将新的IO设备与计算机连接，所要做的只是**为其分配一个新的内存映像并记录它的基地址**（这些配置工作是由操作系统来完成的）。这样一来，程序可以通过操控IO内存映像中的比特数据来实现对相应物理IO外设的操作

---

# Hack硬件平台规范详述The Hack Hardware Platform Specification

Hack平台是16-位冯·诺依曼机，包括一个CPU、两个独立的内存模块（指令内存和数据内存）和两个内存映像I/O设备（屏幕和键盘）

#### Hack的CPU

由第二章介绍的**ALU**和三个分别称为**数据寄存器D data register**、**地址寄存器A address register**、**程序计数器PC program counter**的寄存器组成

D和A是通用的16-位寄存器，可以被算术和逻辑指令使用，D寄存器仅仅用来存储数据值，对于A寄存器，根据指令的内容，A寄存器中的内容可以被解释为数据值、RAM地址或ROM地址

#### Hack机器语言的两种16-位命令类型

地址指令格式0vvv vvvv vvvv vvvv和计算指令格式111a cccc ccdd djjj

#### 计算机体系结构以这样的方式来进行连接

PC（程序计数器）芯片的输出端被连接到ROM芯片的地址输入端。如此一来，ROM芯片总是输出ROM[PC]（大小为一个word），即“PC所指向的指令内存单元”的地址（**这句表达可能不是很恰当吧，应该是输出PC所指向的指令内存单元地址的指令**），这个值称为**当前指令current instruction**

#### 每个时钟周期内整个计算机的操作可以表示为

+ **执行Execute**：当前指令中不同的bit位域被同时被送入计算机中不同的芯片。如果是**地址指令**，即MSB=0，则A寄存器被置为指令中内含的15-位常数。如果是计算指令，即MSB=1，则指令中内含的a-位域、c-位域、d-位域和j-位域被当作是控制位，导致ALU和寄存器会相应的去执行该指令
+ **取指令Fetch**：计算机下一步取哪一条指令，取决于当前指令的jump位和ALU的输出，这些值共同决定了是否去执行跳转。如果需要跳转，则PC被置为A寄存器的值；否则就将PC的值加1，在下一个时钟周期，PC指向的指令在ROM的输出中出现，如此不断循环

这个取指令-执行循环意味着在Hack平台里，涉及内存单元访问的基本操作通常需要两个指令：一个是**地址指令address instruction**，用于将给定的地址赋予A寄存器；以及一个后续的**计算指令compute instruction**，用于对与该地址对应的内存单元进行操作（可以是对RAM单元的读写操作，或是对ROM的跳转操作）

---

数据内存还可以通过内存映像在CPU和计算机输入、输出设备之间充当接口

#### 内存映像Memory Maps

为了使与用户之间的交互变得简单，Hack平台与两个外部设备相连：屏幕和键盘。两个设备都通过内存映像与计算机平台进行接口。通过对屏幕内存映像区段中的单元进行读写，分别实现得到屏幕状态和屏幕绘图操作。同样，可以通过检查键盘内存映像中的内存单元来得知当前按下了哪个键。内存映像通过存在于计算机之外的外部逻辑，与它们各自的IO设备进行交互。交互协议如下：任何时候改变屏幕内存映像中的比特位，相对应的像素就被画在物理显示器上。任何时候在物理键盘上按下一个键，这个键值对应的编码将被存储到键盘内存映像中对应的内存单元内

#### 屏幕：

屏幕可显示256像素行，每行宽512像素，计算机通过内存映像与物理显示设备（即屏幕）进行接口。也就是说，内存映像中的内容与屏幕上的内容是对应的，可通过读写内存映像来操控物理显示设备上的显示，内存单元中的数值对应于屏幕上的一个像素，1=黑色，0=白色

#### 键盘：

Hack计算机跟个人计算机一样可以与标准键盘进行交互，计算机与物理键盘之间通过名为Keyboard的芯片进行交互，当在物理键盘上按下一个键时，它的16-位ASCII码作为Keyboard芯片的输出，当没有按下键时，芯片输出0。除了通常的ASCII码之外，Keyboard芯片还能识别并反映其他一些键

#### 全局内存overall memory

Hack平台的地址空间，也就是它的整个数据内存，是由一个称为Memory的芯片提供的。该芯片包含RAM（用于常规的数据内存和指令内存）和屏幕、键盘内存映像。整个地址空间被分割成4个相互独立的子空间，数据内存、指令内存、键盘和屏幕各占用一个子空间

#### 计算机Computer

Hack硬件阶层体系的顶层是一个单一的芯片**Computer芯片**，作为完整计算机系统的抽象，它能够执行用Hack机器语言编写的程序。Computer芯片包含了运行计算机所需要的所有硬件设备，包括CPU、内存、键盘、屏幕，它们都被集成到该芯片内部，以实现整个计算机功能，为了执行一个程序，该程序的代码首先必须预加载到ROM中，对屏幕和键盘的控制则是通过它们的内存映像来完成的

---

#### 中央处理器CPU The Central Processing Unit的实现

CPU的实现目标是建立逻辑门结构，其能够执行指定的Hack指令和读取下一条要执行的指令

---

在功能方面，计算机系统可以被划分为两个类型：**通用计算机general-purpose computers**，简单地用来执行一个个程序；**专用计算机dedicated computers**，通常嵌入在其他系统中，比如手机、游戏机、数码相机、武器系统、制造设备等等。对于一些特殊的应用，一个单一的程序会被烧写进专用计算机的ROM中，且该程序是唯一能被执行的程序（比如，在游戏机中，游戏软件存储在外部的游戏卡中，他实际上就是可更换的ROM模块，封装在漂亮的包装中）。除了这个显著的区别之外，通用计算机和专用计算机具有相同的结构：存储式程序、“获取-解码-执行”逻辑、CPU、寄存器、程序计数器等

不同于Hack，大多数通用计算机使用单一的地址空间用于存储数据和指令，在这样的结构中，指令中描述的指令地址和可选择的数据地址必须被发送到相同的目的地：共享地址空间的单一地址输入。显然这不能同时完成。**标准的解决方法是将计算机的实现基于双周期控制逻辑**。在**读取循环fetch cycle**中，从内存的输入端输入指令的地址，这样可以立即从内存中取得想要指令，并将该指令暂存到**指令寄存器**中，在接下来的**执行循环execute cycle**中，指令被解码。从中得出操作数所在内存单元的地址，并将该地址从内存的地址输入端输入，从而使指令可以操纵指定的内存单元。相比之下，Hack体系结构将地址空间分为独立的两个部分，允许在同一个时钟周期内实现对指令的读取和执行。这样的简化硬件设计带来的代价是程序不能被动态地改变

---

从发展的历程看，为了加强处理器性能而付出的努力引出了两个主要的硬件设计派系。**复杂指令集计算机CISC，Complex Instruction Set Computing**方法的倡导者认为，为了取得更好的性能，必须提供丰富和详细的指令集。与此相反的是，**精简指令集计算机RISC，Reduced Instruction Set Computing**阵营为了尽可能的提升硬件速度，使用了较简单的指令集，Hack计算机并不加入这场争辩









# 算术逻辑单元是算术和逻辑操作，控制单元是解码，寄存器