# 计算机系统要素：从零开始构建现代计算机

---

# 第七章：虚拟机I：堆栈运算Virtual Machine I: Stack Arithmetic

---

本章介绍构建典型的**基于对象Object-based**的高级语言编译器的最初步骤

#### 首先高级语言将被翻译成中间代码，然后中间代码被转化为机器语言

这种两层two-tier转换模型的思想比较古老，现代高级语言Java、C#等采用

#### 基本思想：中间代码运行在虚拟机Virtual Machine上，而不是真实的硬件平台上

VM是并不真实存在的抽象计算机，但是却能在其他的计算机平台上得以实现。这种思想的**意义**：代码的可移植性

VM能够在多目标平台上相对轻松地实现，因此基于VM的软件不经过修改源代码就可以在不同的处理器和操作系统上运行，VM的实现可以通过多种途径：通过软件翻译器，通过特殊用途的硬件，或者通过把VM程序翻译成目标平台的机器语言

本章介绍典型的VM结构，它是以**Java虚拟机Java Virtual Machine JVM**的模型为蓝本的

虚拟机模型一般配有一种**语言language**，可以利用这种语言来编写**VM程序**

---

本书介绍的VM语言包括4种类型的命令：算术命令、内存访问命令、程序流程控制命令、子程序调用命令

---

#### 虚拟机的出现论证了计算机科学领域里面的很多重要思想

首先，将一台计算机在另一台机器上面进行仿真的概念，是这个领域里的基本思想之一。比如说，在计算机平台上应用模拟器仿真先前的计算机来实现代码的向上兼容。

#### 近来，虚拟机模型成为两种具竞争关系的主流架构的中心焦点——Java体系和.Net架构

这些软件环境相当复杂，要想了解其内部结构，方法之一是构建其VM内核的简单版本

#### 另一个重要主题是堆栈处理stack processing，堆栈stack是基本且精良的数据结构，存在于很多计算机系统和算法中

---

# 背景知识Background

---

## 虚拟机模型The Virtual Machine Paradigm

高级语言程序能够在目标计算机上运行之前，它必须被翻译成计算机的机器语言。这个翻译工作，也就是**编译compilation**，是相当复杂的过程

通常，必须对任意给定的高级程序和其对应的机器语言编写专用的编译器，每种编译器编译的高级语言于编译之后的机器语言之间存在很强的依赖性。减少这种依赖性的方法之一是，将整个编译过程划分为两个几乎独立的阶段。

#### 在第一阶段

高级程序被解析出来，其命令被翻译成一种中间处理结果——既不是“高级”也不是“低级”的中间结果。

#### 在第二阶段

这些中间结果被进一步翻译成目标硬件的机器语言

---

从软件工程的角度来分解是非常吸引人的：第一阶段仅依赖于源高级语言的细节，第二阶段仅依赖于目标机器语言的细节。当然，两个编译阶段之间的接口（接口就是中间处理步骤的精确定义）必须仔细地进行设计。

实际上，该接口的**重要性**之高，甚至应该将其单独定义为一种抽象计算机的语言。其实我们可以明确地描述这种**虚拟机virtual machine**，其指令就是由高级命令分解而成的中间处理步骤。原来作为一个独立程序的编译器现在被分为两个独立的程序，第一个程序，仍然称为**编译器compiler**，将高级代码翻译成中间**VM指令**，第二个程序将这个VM代码翻译成目标计算机硬件平台的机器语言

#### .NET需要编译器来生成用IL中间语言Intermediate Language编写的代码，此中间语言运行在称为通用语言运行时Common Language Runtime，CLR的虚拟机上

---

明确且正式的虚拟机语言概念有很多务实的优点。首先，仅需要替换虚拟机实现部分（有时候称为编译器的**后端程序，backend**）就能相对容易地得到不同硬件平台的编译器

因此，虚拟机在不同硬件平台之间的可移植性可以实现代码效率、硬件成本和程序开发难度之间的权衡。其次，很多语言的编译器能够共享VM后端程序，允许代码共享和语言互用性，比如，某种高级语言善于科学计算，而另一种在处理用户接口方面很突出，如果把两种语言编译到通用的VM层，那么通过使用约定的调用语法，其中一种语言的程序就能够很容易地调用另一种语言的程序

虚拟机方法的另一个优点是**模块化**。VM效率的每一个改善都会立即被所有构建于其上的编译器继承，同样地，每个安装有VM实现的数字设备都能够受益于现有软件的庞大基础

---

## 堆栈机模型The Stack Machine Model

像很多程序语言一样，VM语言包含算术操作、内存访问操作、程序流程控制操作、子程序调用操作。由很多软件实体可作为VM语言的实现，但在选择中要考虑的关键是：

#### 在VM操作中的操作数和结果应该驻留在哪里。最干净利落的解决方法就是将其放在堆栈stack数据结构里面

---

在**堆栈机stack machine**模型里，算术命令将其操作数从堆栈顶弹出，并将结果从栈顶压入。其他的命令将数据项从堆栈顶弹出，并转移到指定的内存单元，或反向操作之。

#### 经证明，这些简单的堆栈操作可以被用来计算任何数学或逻辑表达式。此外，任何程序，不管它用哪种程序语言编写，都能被翻译成等价的堆栈机语言

这样的堆栈机模型能够被应用在**Java虚拟机**上

---

# 基本堆栈操作

堆栈是抽象的数据结构，它支持两个基本操作：**压入push**和**弹出pop**

压入操作是从堆栈顶部压入一个元素，当有新的元素从栈顶压入时，原栈顶的元素就向下移动一个单位；弹出操作是将栈顶的元素弹出，原来位于被弹出元素之下的元素就向上移动一个单位到达栈顶。

## 堆栈执行的是“后进先出”last-in-first-out，LIFO的存储模式

堆栈存取在很多方面不同于普通的内存访问

+ 首先，堆栈只有顶部一个出入口，一次只能存/取一个元素
+ 其次，读取堆栈是一种“**丢失**”操作：读取栈顶元素值的唯一方法是将其从堆栈中**移除**。相比之下，从普通内存单元读取值的行为就不会对内存的状态产生影响
+ 最后，给堆栈添加新元素的操作就是直接将其压入栈顶，而不会改变堆栈的其余部分，然而，将值赋予一个普通的内存位置则是“**丢失**”操作，因为它覆盖了该内存单元内原来的值

堆栈数据结构可以通过很多方法来实现，最简单的方法是创建一个数组（就是所谓的堆栈）和一个**堆栈指针变量**（称为sp，stack pointer）指向位于栈顶的元素。

#### 按照惯例，堆栈被描述为栈顶朝下，并向下增长的数据结构。紧挨着栈顶的内存单元由一个特殊的指针来引用，该指针称为堆栈指针，即sp

---

在计算机科学领域里，表达式简单优雅意味着强大的表达能力，结构简洁的堆栈模型是具备多功能的数据结构，它在许多计算机系统和算法中得到应用。这里构建的虚拟机体系里面，堆栈主要有两个用途：首先，被用来处理所有VM的算术和逻辑操作；其次，它使得子程序调用和相关的内存分配变得容易

#### 堆栈运算

#### 基于堆栈的运算是很简单的：操作数从堆栈弹出，对它们执行相关的操作，然后将结果压入堆栈

一个通用观点：

#### 任何算术表达式和布尔表达式（不管多复杂）都能被系统化地转化成一系列在堆栈上的简单操作，并被系统化地计算出来

```assembly
// d=(2-x)*(y+5) 假设x=5，y=9
push 2
push x
sub
push y
push 5
add
mult
pop d
// if (x<7) or (y=8)
push x
push 7
lt
push y
push 8
eq
or
```

---

#### VM规范详述，第一部分

虚拟机是**基于堆栈**的stack-based：所有的操作都在堆栈上完成，它也是**基于函数**的function-based：一个完整的、应用VM语言编写的VM程序由若干个称为**函数functions**的程序单元组成，这些函数使用VM语言编写。每个函数都有自己独立的代码，并被独立地处理。VM语言使用单一的16-位数据类型，它能够表示整数、布尔类型，或者指针。该语言包含四种类型的命令：

+ **算术指令**：在堆栈上执行算术和逻辑操作
+ **存储器存取命令**：在堆栈和虚拟内存单元之间转移数据
+ **程序流程命令**：使条件分支操作和无条件分支操作变得容易
+ **函数调用命令**：调用函数并返回调用处（即函数调用指令的下一条指令地址）

#### 程序和命令结构

VM程序是由一个或多个扩展名为.vm的文件构成的集合，而每个程序又包含一个或多个函数。从编译的角度来看，这些结构分别与面向对象编程语言中的程序program、类class和方法method的概念相对应

在.vm文件中，每一行一个VM命令，按照下面所列的格式之一来书写
命令（比如，add）
命令  参数（比如，goto loop）
命令  参数1  参数2（比如，push local 3）

---

#### 算术命令和逻辑命令Arithmetic and Logical Commands

VM语言有9个面向堆栈的算术命令和逻辑命令。其中的7个命令是二元的：从堆栈中弹出两个元素，在其上执行二元函数操作，然后将结果压回堆栈，剩下的两个命令是一元的，只从堆栈中弹出一个元素，在其上执行一元函数操作，然后将结果压回堆栈，可以看到每个命令仅会用操作结构来取代他的操作数，而对堆栈的其他部分没有影响

#### 内存访问命令

VM操纵8个独立的**虚拟内存段virtual memory segments**，所有的内存段都通过相同的两个命令来进行存取

+ push segment index 将segment[index]的值压入堆栈
+ pop segment index 将栈顶元素弹出然后存入segment[index]

例如：push argument 2和pop local 1语句将会把函数的第三个参数的值存储在函数的第二个局部变量中

除了这8个虚拟内存段可被VM的pop和push直接操纵，VM还操纵两个暗含的数据结构称为**堆栈stack**和**堆heap**。这些数据结构从来不会被直接提到，但随着VM对它们进行操作，它们的状态却会在后台变化

#### 堆栈stack

push argument 2和pop local 1，这样的VM操作的工作内存就是堆栈。数据值并不是简单地直接从一个单元跳到另一个单元，而是必须经过堆栈中转，尽管堆栈是VM结构中的核心角色，但是在VM语言中从未显式地体现出它的功能

#### 堆heap

处在VM后端的另一个数据结构就是堆，堆是RAM区域的名字，用来存储对象和数组数据，这些对象和数组能够通过VM命令来操纵

---

#### 程序流程控制命令和函数调用命令Program Flow and Function Calling Commands

---

#### Jack-VM-Hack平台中的程序元素Program Elements in the Jack-VM-Hack Platform

汇编程序主要处理的两件事情：首先，对每个VM函数和文件的虚拟内存单元以及隐含的堆栈进行仿真，然后，在目标平台上执行VM命令。这是通过使用机器语言指令（由VM命令翻译而来）操纵仿真的VM数据结构来实现的

---

#### VM编程实例VM Programming Examples

---

# 程序结构Program Structure

本书采用一个主程序和两个模块：parser和codewriter来实现VM翻译器（即VM实现机制）

#### Parser模块

分析.vm文件，封装对输入代码的访问，它读取VM命令并解析，然后为它们的各个部分提供方便的访问入口。此外，还移除代码中所有的空格和注释

#### CodeWriter模块

将VM命令翻译成Hack汇编代码

#### 主程序

主程序应该构造一个parser和一个CodeWriter；Parser用来解析VM输入文件；CodeWriter用来将生成的hack汇编代码写入相应的输出文件.asm文件中。另外，主程序应该读取输入文件中的每一条命令并为其生成对应的汇编代码

---

本章开发了用于高级语言的编译器，遵循现代软件工程实践的经验，采用了两层two-tier编译模型来进行开发。在**前端frontend**层级，高级代码被翻译为运行在虚拟机上的中间代码，在**后端backend**层级，中间代码被翻译为目标硬件平台的机器语言

JVM是一种规范，描述了Java编译器的目标语言，即称为bytecode的中间语言，用bytecode编写的文件被作为Java程序的动态代码发布版本在互联网上进行发布，最常用的是嵌在网页里面的applets（Java小应用程序），当然，为了运行这些程序，客户端计算机必须安装相应的JVM实现。这种JVM实现也称为**Java Run-time Environment JREs Java运行时环境**，在许多“处理器/OS”平台（包括游戏机和手机）上被广为采用

21世纪头十年之初，微软Microsoft公司通过推出.NET体系架构加入了此领域。.NET的核心是称为**Common Language Runtime CLR 公共语言运行时**的虚拟机模型

需要注意的是，在虚拟机模型发挥互操作性的巨大潜力之前，必须要将一个关键成分加入虚拟机模型，这个成分就是**通用软件程序库common software library**。Java虚拟机带有Java程序库，微软的虚拟机带有CLR，可以将这些软件程序库看作小型操作系统，为运行在虚拟机上的语言提供了统一的服务，比如内存管理、GUI组件、字符串处理函数、数学函数等等

---

# 实现Implementation

需要在真实的平台上实现虚拟机。构建这样的VM，从概念上包含两个任务，首先必须在目标平台上对VM进行仿真。特别是，VM规范提到的每个数据结构，也就是堆栈和虚拟内存段，都必须通过某种方式在目标平台上表示出来。其次，每个VM命令都必须被翻译成一系列具有目标平台语意的指令

首先定义从VM要素和操作到Hack硬件和机器语言之间的“标准映射”。然后，提出实现这种映射的软件设计思路

---

## Hack平台上的标准VM映射，第1部分Standard VM Mapping on the Hack Platform, Part 1

VM设计者应该允许程序员用任何他们觉得合适的途径去在目标机上实现VM。然而，我们建议将一些关于VM应该怎样映射到目标平台的设计指南提供给设计人员，而不是去把这些决策性的东西全都交给设计者来决定，这些指导性的原则，称为**标准映射standard mapping**

#### 从VM到Hack的翻译

.vm文件作为输入，产生一个单一的Hack汇编语言.asm文件作为输出。.vm文件中函数的顺序对程序的执行没有影响

#### RAM用法

Hack计算机的数据内存由32K个16-位字组成，前16K作为通用RAM，下一个16K包含IO设备的内存映像。VM实现应该使用如下的间隔分配方式

| RAM地址     | 功用                         |
| ----------- | ---------------------------- |
| 0-15        | 16个虚拟寄存器               |
| 16-255      | VM程序的所有VM函数的静态变量 |
| 256-2047    | 栈                           |
| 2048-16383  | 堆（用于存放对象和数组）     |
| 16384-24575 | 内存映像I/O                  |

汇编程序可使用符号SP、LCL、ARG、THIS和THAT来分别指代RAM地址0-4

| 寄存器     | 名称 | 功用                           |
| ---------- | ---- | ------------------------------ |
| RAM[0]     | SP   | 栈指针：指向栈中下一个最顶位置 |
| RAM[1]     | LCL  | 指向当前VM函数local段的基址    |
| RAM[2]     | ARG  | 指向当前VM函数argument段的基址 |
| RAM[3]     | THIS | 指向当前this段（在堆中）的基址 |
| RAM[4]     | THAT | 指向当前that段（在堆中）的基址 |
| RAM[5-12]  |      | 保存temp段的内容               |
| RAM[13-15] |      | 可被VM实现用作通用寄存器       |

#### 内存段映射

local，argument，this，that：每一个这样的段都被直接映射到RAM；通过专用寄存器（分别是LCL，ARG，THIS，THAT）来保存，其物理基地址，就可以维持其在RAM中的位置。如此一来，对这些段的第i个数据项的访问，应该被翻译成“获取RAM中地址为（base+i）的值的汇编代码”，这里base是存储在各段专有寄存器中的当前值

pointer，temp：这些段被直接映射在RAM中的一个固定区域上，pointer段被映射在RAM位置3-4（也称为THIS和THAT）上，temp段被映射在RAM位置5-12（也称为R5, R6,...,R12）上。因此访问point i应该被翻译成访问RAM位置3+i的汇编代码，访问temp i应该被翻译成访问RAM位置5+i的汇编代码

Constant：这个段是真正虚拟的，因为它不占用目标平台上的任何物理存储空间，VM实现通过简单地提供常数i来处理任何VM对constant i的访问

Static：根据Hack机器语言规范，在汇编程序中每遇到一个新的符号时（**个人理解，应该是变量**），编译器就为其分配一个新的RAM单元，从地址16处开始

#### 汇编语言符号

所有在VM实现机制中使用的汇编语言符号，它们符号标准映射规范
SP，LCL，ARG，THIS，THAT，R13-R15，XXX.j符号，控制流符号