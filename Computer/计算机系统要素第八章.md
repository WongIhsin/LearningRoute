# 计算机系统要素：从零开始构建现代计算机

---

# 第八章：虚拟机II：程序控制Virtual Machine II: Program Control

---

在计算机科学领域的竞赛中，**堆栈处理stack processing**绝对是进入决赛的强大选手

高级语言抽象级别越高，在底层要做的工作也越多。特别是，必须在底层控制**子程序**和**子程序调用者**（执行诸如sqrt和power的系统定义和用户定义操作的程序单元）之间的相互影响。对于在运行期的每个子程序调用，底层必须处理下面的一些细节

+ 将参数从调用者caller传递给被调用者called subroutine
+ 在跳转并执行被调用者之前，先保存调用者的状态
+ 为被调用者使用的局部变量分配空间
+ 跳转并执行被调用者
+ 将被调用者的运行结果返回给调用者
+ 在从被调用者返回之前，回收其使用的内存空间
+ 恢复调用者的状态
+ 返回到调用语句之后的下一条语句继续执行

用**堆栈机stack machine**来完成底层操作

#### 事实上堆栈结构本身的优势就在于处理这种类似任务

---

## 程序流控制Program Flow

计算机程序默认的执行顺序是线性的，即一个命令接着一个命令执行，这个连续的控制流偶尔被分支命令打断（比如在循环中执行迭代）

目的地址的指定方式可以有多种形式，最原始的一种就是指定即将执行的指令的物理地址。应用标签label来描述jump的目的地址可以建立稍微抽象一点的**重定向命令redirection command**。这种改进需要程序语言配有**标签指令labeling directive**，它可以将标签绑定到程序中指定位置

VM命令label、goto label和if-goto label的底层实现是很容易的，所有的编程语言（包括“最”底层的）都有某种分支命令结构，例如，如果底层实现是基于将VM命令翻译成汇编代码，那么我们所要做的就是利用汇编语言的分支逻辑来重新表达goto命令

---

## 子程序调用Subroutine Calling

每种编程语言都有的特征是具有一组固定的内置命令集合。现代编程语言抽象机制的关键是**允许程序员应用自定义的高级操作自由地扩展该语言的基本指令集**。在**过程化语言procedural language**中，高级操作称为**子程序subroutines**、**过程procedures**或者**函数functions**；在面向对象的语言中，它们通常称为**方法methods**

在优秀的编程语言中，高级操作（利用一个子程序来实现）的使用与使用语言本身自带命令的感觉一样

调用内置命令和调用用户定义的子程序之间的唯一区别是用户自定义子程序之前要有关键字call。除此之外，内置命令和用户自定义子程序的实现过程都是一样的：

#### 两者都需要调用者将参数传递给被调用者，被调用者从堆栈中取出参数，在被调用者结束时将其处理结果压入堆栈返回给调用者

基本命令（比如add）和高级函数调用（比如power）在参数处理和返回值方面是一致的

```assembly
// (x^3+2)^y
push x
push 3
call power
push 2
add
push y
call power
```

```assembly
// Power函数
// result = 以第一个参数为幂第二个参数为底的计算结果
function power
// 此处代码省略
push result
return
```

子程序（比如power）通常都会使用局部变量local variables进行临时存储。在子程序的“生命周期”中，也就是从子程序开始执行直到遇到return命令为止，必须为这些局部变量分配内存。在子程序返回时，这些被局部变量占用的内存将被释放。

当允许子程序被任意嵌套时，子程序的调用机制会变得很复杂：一个子程序可以调用另一个子程序；被调用的子程序还可以进一步去调用其他子程序，如此嵌套。而且还允许子程序递归地调用自己；每个递归调用必须独立于其他调用，并且维护其自身的局部变量和参数

---

调用和返回逻辑的线性嵌套分层特点让这个繁琐任务变得容易管理。虽然子程序调用链可以具有任意深度，可以有任意的递归，但是在任何时刻，只有调用链顶部的子程序才能被执行，而处于调用链中其他子程序将一直等待到该子程序执行完毕为止才能继续执行

在子程序调用的实现过程中，这种**后进先出Last-In-First-Out，LIFO**的处理方式和堆栈数据结构的操作方式完全吻合

#### 当子程序xxx调用子程序yyy时，可以将xxx的环境变量压入（保存到）堆栈中，然后转去执行yyy，当yyy返回时，再将xxx的环境变量从堆栈中弹出（恢复），如果没有特殊的情况出现就继续执行xxx

在概念上使用**帧frame**来代表子程序的局部变量的集合，它包括**子程序的参数**、**工作堆栈**和运行过程中**所使用的内存段**

现在起

#### 堆栈stack是指全局堆栈，是由当前子程序的帧，和所有正在等待该子程序返回的其他子程序的帧所构成的内存区

在call xxx操作的底层实现中，先将调用者的帧保存到堆栈中，然后为子程序xxx的局部变量分配堆栈空间，最后跳到子程序xxx开始执行其代码

目标子程序的名字在call命令中已经被指定了，这样在调用过程中

#### 可以将这个目标程序名解析成一个内存地址，然后跳转到以该内存地址为基址的代码段（该代码段就是子程序的代码段）开始执行

return时候，因为命令中并未指定返回地址，事实上，在所有调用子程序的过程中，调用者的返回地址都没有显式地给出

#### return命令应该按如下方式来解释：他将程序的执行重定向到调用语句call命令的下一条命令所在的内存地址（不论这条命令的内存位置具体在哪），即称为返回地址return address

当我们用call xxx指令执行调用操作时，应该知道准确的返回地址：指令call xxx的下一条指令的内存地址。因此，将该指令内存地址作为返回地址压入堆栈保存，然后去执行子程序。当我们最终遇到return命令时，我们就将先前保存在堆栈汇中的返回地址弹出来，然后只用简单的goto命令跳转到这个地址

#### 换句话说就是返回地址也可以保存在调用者的帧里面

---

## VM规范详述，第II部分VM Specification, Part II

#### 程序控制流命令Program Flow Commands

+ label *label*该命令标记程序中某条指令的位置，在程序中的跳转指令只能跳转到被label *label*命令所标示的位置，label标签所指示的代码段范围就是程序中定义的函数体。label可以是由任意字母、数字、下划线、点和冒号组成的字符串，不能以数字开头
+ goto *label*该命令执行**无条件跳转**操作，使得程序跳转到label *label*命令标示的位置那里继续执行。跳转的目的地址必须位于同一个程序之内
+ if-goto *label*该命令执行**条件跳转**操作。首先，将布尔表达式的运算结果从堆栈顶端弹出，如果该值非0，那么程序就跳转到label标示的位置继续执行；否则，继续执行程序中的下一条命令，跳转的目的地址必须位于同一个函数内

---

#### 函数调用命令Function Calling Commands

不同高级语言对于程序单元program units概念采用不同的名称，包括**函数function**、**过程procedure**、**方法method**以及**子程序subroutine**

在整个编译模型中，每个高级程序单元都被翻译成**VM函数**，或简称为**函数**

函数的名称是个全局量，可是由任意字母、数字、下划线、点以及冒号组成的字符串，不能以数字开头。函数名称的使用范围是全局的，即所有文件中的所有函数可通过这种全局名称互相调用

+ function f n：一段函数名为f的代码，该函数有n个参数
+ call f m：调用函数f，其m个参数已经被调用者压入堆栈
+ return：返回到调用者

---

#### 函数调用协议The Function Calling Protocol

+ 调用者的角度
  + 在调用函数之前，调用者必须将必要的参数压入堆栈
  + 接着，调用者使用call命令来调用函数
  + 被调用函数返回后，调用者先前压入堆栈的参数将被删除，并且函数的返回值将出现在栈顶
  + 被调用函数返回后，调用者的各内存段跟调用之前一样
+ 被调用者的角度
  + 当被调用的函数开始执行，其argument segment段被初始化为调用者所传递的参数，为其local segment段分配内存空间并初始化为0，它的static segment段被置为其所属vm文件中的static segment，工作堆栈为空，This、that、pointer和temp四个指针均未初始化
  + 返回前，被调用函数必须将某个值压入堆栈

#### 每当VM函数开始运行（或继续前面的执行）时，要保证其处于自己的私有空间之内，这个私有空间是由各函数的虚拟内存和堆栈组成。VM函数的指令就对其私有空间内的各个虚拟内存段和堆栈进行操作。VM实现机制负责构建各VM函数的私有空间

---

#### 初始化Initialization

VM程序是一组相关的VM函数集合，一般来自于某种高级程序的编译。当VM实现开始运行（或者重启）时，按照惯例它总是执行名为Sys.init的无参数VM函数。接着该函数调用用户程序中的主函数，因此，生产VM的编译器必须保证每个翻译后的程序都有个这样的Sys.init函数

---

## 实现Implementation

---

#### Hack平台上的标准VM映射，第II部分Standard VM Mapping on the Hack Platform, Part II

#### 全局堆栈

VM的内存资源是通过维护一个全局的堆栈来得到的。每当调用一个函数时，该函数对应的**帧frame**就被压入全局堆栈。该帧包括**被调用函数called function**将要使用的参数；一组用于保存调用者状态的**指针pointers**；被调用函数的**局部变量**（被初始化为0）；以及一个被调用函数将要使用的**工作堆栈**（当前为空）

#### 调用链中所有函数的调用帧

当前函数的参数被压入堆栈

+ argument 0	←ARG
+ argument
+ ...
+ argument n-1

保存调用函数状态，以便在当前被调用函数返回时，恢复调用函数的帧

+ return address
+ saved LCL
+ saved ARG
+ saved THIS
+ saved THAT

当前被调用函数的局部变量

+ local 0	←LCL
+ local 1
+ ...
+ local k-1

当前被调用函数的工作堆栈

+ ←SP
+ 

---

#### 函数调用协议的实现

VM实现是高级语言编写的**翻译器（translator）**程序，以VM代码作为输入，然后生成汇编代码作为输出

| VM命令                                            | VM实现生成的（伪）代码                                       |
| ------------------------------------------------- | ------------------------------------------------------------ |
| call f n<br />(在n个参数被压入堆栈之后调用函数f)  | push return-address //(使用下面声明的标签)<br />push LCL //保存调用函数的LCL段指针<br />push ARG //保存调用函数的ARG段指针<br />push THIS //保存调用函数的THIS段指针<br />push THAT //保存调用函数的THAT段指针<br />ARG=SP-n-5 //重置ARG(n=参数数量)<br />LCL=SP //重置LCL<br />goto f //跳转控制<br />(return-address) //为返回地址声明一个标签 |
| function  f k<br />(声明一个有k个局部变量的函数f) | (f) //为函数入口声明一个标签<br />repeat k times: //k=局部变量的个数<br />PUSH 0 //将他们全部初始化为0 |
| Return<br />(从当前函数返回)                      | FRAME=LCL //FRAME是临时变量<br />RET=`*(FRAME-5)` //将返回地址放入临时变量中<br />`*ARG`=pop() //重置调用者的返回值<br />SP=ARG+1 //恢复调用者的SP<br />THAT=`*(FRAME-1)` //恢复调用者的THAT段指针<br />THIS=`*(FRAME-2)` //恢复调用者的THIS段指针<br />ARG=`*(FRAME-3)` //恢复调用者的ARG段指针<br />LCL=`*(FRAME-4)` //恢复调用者的LCL段指针<br />goto RET //跳转到返回地址（在调用者代码中） |

#### 汇编语言符号

程序控制流program flow命令和函数调用function calling命令的实现需要VM实现在汇编语言层创建并使用特殊的符号symbol

SP、LCL、ARG、THIS、THAT、R13-R15、Xxx.j

**functionName$label**：在VM函数f中的每个label b命令应该生成唯一的全局符号“f$b”，这里“f”是函数名，“b”是VM函数体内的标记符号。在将VM命令goto b和if-goto b翻译成目标语言时，应该使用完整的符号“f$b”，而不是“b”

**(FunctionName)**：每个VM函数f应该生成一个符号“f”，以指代函数f在目标计算机指令内存中的地址入口

**return-address**：每个VM函数调用应该生成并在翻译后的代码中插入唯一的标号，它代表被调用函数（called function）的返回地址，即内存单元的地址（目标计算机的内存），该地址就是紧接着调用命令之后的指令地址

---

#### 引导程序bootstrap代码

当VM-Hack翻译器编译VM程序（一组.vm文件）时，会产生一个用Hack汇编语言编写的.asm文件，该文件必须符合规范。标准映射规定：（1）VM堆栈的初始地址必须被映射到RAM[256]；（2）经过编译后的VM程序所执行的第一个VM函数必须是Sys.init

起始于ROM地址0的代码段，称为**引导程序代码bootstrap code**，是计算机启动时要执行的第一段代码。
SP=256				//将堆栈指针初始化为0x0100
call Sys.init		//开始执行（翻译后的）Sys.init

Sys.init将调用主程序中的主函数，然后进入无限循环。这样翻译后的VM程序就进入运行状态

换句话说，当被调用函数的任务完成之后，调用函数也得到了期望的服务，程序继续执行就好像没有发生任何事情一样：除了函数的返回值，mult函数的执行过程（中间的堆栈实例）在堆栈上不会留下任何痕迹

---

## 观点Perspective

子程序调用subroutine calling和程序流控制program flow的概念对于所有高级语言都是很基本的，这意味着在将程序转换成二进制代码过程中的某些地方，必须考虑与其实现相关的一些复杂操作。在Java、C#和Jack中，这个任务落在VM层上，如果VM是**基于堆栈stack-based**的，就能很好地解决这些复杂问题。

#### 一般而言，以“子程序调用和迭代的实现”作为基本特征的虚拟机都能表达有意义的抽象

这当然只是对实现机制的选择，一些编译器直接处理子程序调用的细节，而根本不用VM。其他编译器则使用各种形式的VM，但是他们对程序调用的处理并不是必须的。最后，在一些体系结构中大多数子程序调用功能是直接被硬件处理的