# 计算机系统要素：从零开始构建现代计算机

---

# 第十章：编译器I：语法分析Compiler I: Syntax Analysis

编译器是一种程序，能将高级语言程序从源语言翻译成目标语言，这个翻译过程（即**编译，compilation**）从概念上讲由两个不同的任务组成。

首先，我们必须理解源程序的**语法syntax**，以此来揭示程序的**语义semantics**。比如，对代码进行语法分析可得知程序想要或操纵对象。

该信息让我们能够使用目标语言的语法来重构程序的逻辑。

第一个任务通常称为**语法分析syntax analysis**，第二个任务，即**代码生成code generation**

---

本章构建编译器的**语法分析器syntax analyzer**模块

怎么能断定编译器是否能够“理解”语言的语法呢？其实，只要编译器生成的代码能执行期望的任务，就该乐观地认为该编译器执行了正确操作

---

为什么要不嫌麻烦地构建编译器呢？首先，对编译过程内部原理的掌握将会使你成为更好的高级程序员，其次，用于描述编程语言的规则和语法，同样也能用于描述不同应用（从计算机制图到数据库管理，再到通信协议，以至生物信息学）中的数据集的语法。

#### 虽然大多数程序员在编程生涯中不必开发编译器，但很有可能需要分析和处理某种复杂语法的文件。这些任务与分析编程语言一样，采用相同的概念和技术

---

# 背景知识Background

典型的编译器由两个主要模块组成：**语法分析syntax analysis**模块和**代码生成code generation**模块

# *语法分析* + 代码生成

#### 字元化 + 语法分析

语法分析任务通常可进一步分为两个模块：**字元化tokenizing**模块将输入的字符分组成语言原子元素language atoms；然后由**语法分析parsing**模块将所得到的语言原子元素集合同语法规则相匹配。

这些行为相对于目标语言是完全独立的

语法分析，任务是“**理解高级源程序的结构**”。如果只考虑**形式语言**（因其简单性而几乎不配被称为“语言”），就能准确地知道如何将其语法结构形式化。通常使用一组称为**上下文无关语法context-free grammar**的规则来描述编程语言。要理解（即解析）给定的程序，就意味着要决定程序文本和语法规则之间的准确对应。为了做到这一点，首先必须将程序的文本转换成一系列**字元token**

# 本章：语法分析

+ 词法分析lexical analysis、上下文无关语法、语法分析树parse trees，以及用于分析它们的递归下降recursive-descent算法

---

## 词法分析Lexical Analysis

程序最简单的语法形式就是存储在文本文件中的一系列字符。对程序进行语法分析的第一步，是将字符分组成**字元**（由语言语法所定义），忽略空格和注释

这一步通常称为**词法分析lexical analysis**、**扫描scanning**或**字元化tokenizing**

#### 一旦程序被分组成字元，字元（不是字符）就被看作程序的基本原子，字元集合就成为编译器的输入

#### 编程语言通常都会指定其所允许的字元类型，以及用于将字元组合成正确程序结构的准确语法规则（例如一些语言规定++为合法操作符字元，一些编译器认为++字符组成的标记是不合法的）

```java
while (count <= 100) {
    /** 循环 */
    count++;
    //其他语句
    //...
}
```

字元

```java
while
(
count
<=
100
)
{
count
++
;
}
...
```

如上，字元包括不同的种类（或称类型），比如while是**关键字keyword**，count是**标识符identifier**，<=是**操作符operator**，等等

---

## 语法Grammar

一旦对程序进行语法分析，形成一系列字元（即**字元流，token stream**），就面临更具挑战性的任务，即将字元进行分析，理解成对应的规范结构。换句话说，

# 必须想办法考虑如何将这些字元分组成变量声明、语句、表达式等等的语言结构

通过将字元集合按照预定义的**规则集set of rules**，即**语法grammar**进行组合分配，就可以实现分组和分类任务

#### 几乎所有的编程语言，以及大多数用于描述复杂文件类型语法的其他的形式语言，都可以使用上下文无关语法context-free grammars来描述。上下文无关语法是一组规则，用来指定语言中的语法元素如何由更简单的元素组成。比如，Java语法允许将基本元素100、count和<=联合成表达式count<=100。同样的Java语法允许确定文本count<=100是正确的Java表达式

事实上，每种语法都可以从两个方面来考察，从声明的观点来看，语法规定了可行的方案，来将字元（token，也称为**终结符terminals**）组合成更高级的语法元素（也称为**非终结符non-terminals**）。从分析的观点来看，语法是用于执行反向任务的规则：将给定的输入，即通过字元化阶段tokenizing phase得到的字元集合，解析成非终结符、较低级的非终结符，以及最后不能继续分解的终结符

#### 本章使用这样的表示法来描述语法：

#### 终结符用单引号括起来的粗体字表示，非终结符用一般字体表示。当有不止一种方法来分析非终结符时，就使用"|"符号列出可能的结果

---

## 语法分析Parsing

检查语法是否将所输入的文本看作合法输入，这个过程称为**语法分析parsing**

因为语法规则是分层的，所以**语法分析器parser**生成的输出可以用称为**语法分析树parse tree**或**导出树derivation tree**的树状数据结构来描述

## 递归下降分析Recursive Descent Parsing

有很多算法可用来构建语法分析树。

#### 自顶向下的方法，也称为**递归下降分析**，是应用由语法规则描述的嵌套结构来尝试递归地分析字元集合形成的输入流。

对于语法中每个描述非终结符的规则，可以为语法分析器程序配备递归子程序，该子程序用来递归地分析非终结符。如果非终结符仅由终结符原子构成，该程序就很容易处理它们，否则，对于规则右边的每个非终结符**构建块building block**，程序可以递归地调用“分析该非终结符”的程序。整个处理过程递归进行，直到所有终结符原子元素全部被处理完毕

---

例如

```c
while (count<=100) {
    count++;
    //...
}
```

```c
statement: whileStatement | ifStatement | ... | '{' statementSequence '}'
whileStatement: 'while' '(' expression ')' statement
ifStatement: ... // 'if'的定义
statementSequence: '' // Null
			| statement ';' statementSequence
expression: ... // 表达式的定义
```

如果输入流如上所描述的，程序会确定第一个字元是while，然后调用相应的parseWhileStatement()子程序。根据相应的whileStatement语法规则，该程序接下来应该读取终结符“while”和“(”，然后调用parseExpression()来分析非终结符expression(表达式)，在该函数返回后（本例中分析了“count<=100”序列），根据语法规定，这时parseWhileStatement()读取的终结符应该是“)”，然后递归调用parseStatement()。该调用将会递归进行下去，直到读取的字元都是终结符为止。

同样的逻辑也可以用来检查源程序中的语法错误，编译器越好，错误诊断的能力就越强

---

#### LL(0)语法

递归分析算法是简单高效的算法，唯一可能的复杂性在于分析的非终结符有多种可选的解释

#### 每当一个非终结符有多种可选择的导出规则时，其第一个字元足以确定该非终结符所属的表达式类型，而不会出现不确定的情况。具有这种属性的语法称为LL(0)，递归下降算法可以简洁明了地处理这类语法

当第一个字元不足以确定元素的类型时，对下一个字元“提前查看”有可能可以解决这种不确定性。这种分析显然是可以做到的，但当我们需要顺着字元流去读取越来越多的字元时，分析就变得复杂起来。

Jack语言语法，几乎就是LL(0)，可以通过递归下降分析器来recursive descent parser处理，唯一的例外就是表达式的分析，在必要时需要“提前查看”后续字元

#### 唯一的例外就是表达式的分析expression

---

# 规范详述Specification

#### Jack语言的语法分析器A Syntax Analyzer for the Jack Language

**语法分析器syntax analyzer**的主要目的是读取Jack程序，根据Jack语法“理解”其语法结构，“理解”的意思是语法分析器在处理过程中的每一步都必须确定当前读取的程序要素是**expression**或**statement**或**variable name**等等。语法分析器必须以完全递归的形式来保存语法结构的信息。没有此信息，就不可能进入下一步的代码生成阶段（代码生成是整个编译器项目的最终目标）

---

#### 语法分析器的输入The Syntax Analyzer's Input

#### 语法分析器的输出The Syntax Analyzer's Output

语法分析器必须辨识语言构造中的两个主要类型：终结符和非终结符

Jack语言包括5种终结元素（即字元）：关键字keyword、符号symbol、integerConstant整数常量、StringConstant字符串常量、identifier标识符

---

# 实现Implementation

---

#### JackAnalyzer模块：对于给定的source进行操作

使用CompilationEngine来将输入的JackTokenizer编译成输出文件

#### JackTokenizer模块

从输入流中删除所有的注释和空格，并根据Jack语法的规则将输入流分解为Jack语言的字元（终结符）

#### CompilationEngine模块

执行编译输出。从JackTokenizer中得到输入，然后将分析后的结果放入输出文件或输出流。输出是通过一系列compilexx()子程序生成的，每个子程序对应Jack语法中的一个语法要素xxx

每个compilexxx()程序应该从CompilationEngine的输入中读取语法要素xxx，利用advance()函数取出当前要素xxx的下一个要素，并输出当前要素xxx的分析结果。

仅当下一个要素是xxx时，才会调用该要素对应的分析函数compilexxx()

---

## 观点Perspective

编译器并不需要显式地维护语法分析树的数据结构

本章描述的语法分析算法是“实时”的，意味着在读取输入时就立即进行分析，在内存中并不存储编译器输入的整个源程序

本章回避了所有在典型编译课程中研究的形式语言理论，回避了比本章介绍的自顶向下分析算法功能更强大，技术更复杂的分析算法

#### 如何描述语言的语法——形式语言formal languages

它讨论了各类语言的属性，包括元语言metalanguages及其描述形式。这也是计算机科学与人类语言的交叉点，形成了交叉研究学科——计算机语言学computational linguistics

---

语法分析器并不是独立的程序，人们很少从头凭空开始编写语法分析器，通常使用各种“生成编译器”的工具来构建字元转换器tokenizers和分析器parsers，这类工具如LEX（LEXical analysis）和YACC（Yet Another Compiler Compiler），这些工具接收上下文无关语法作为输入，生成法分析代码（能够对按此语法编写的程序进行字元转换和语法分析）作为输出。然后，就可以对生成的代码进行定制，以满足不同应用的特定编译需求

